// Signature file for parser generated by fsyacc
module Parser
type token = 
  | QUOTED of (string)
  | AXIS of (string)
  | TOOLOVERSIZE of (string)
  | MCOMMAND of (string * string list * int)
  | MCODE
  | SCODE
  | FCODE
  | FUNIT of (string)
  | FMAX
  | FAUTO
  | POLAR of (string)
  | DRMINUS of (string)
  | DRPLUS of (string)
  | RADIUSCOMPENSATION of (string)
  | CHF
  | CC
  | C
  | CP
  | CR
  | CT
  | CTP
  | RND
  | FK
  | APPROACHSTRATEGY of (string)
  | LEN
  | R
  | CCA
  | APPR
  | DEP
  | LINE
  | LP
  | LN
  | LBL
  | REP
  | CALLLBL
  | POSX of (string)
  | PATTERNDEF
  | TOOLCALL
  | ENDPGM of (string)
  | COMMAND of (string * string list * int)
  | DIVERSEFUNCTION of (string)
  | FN
  | COLON
  | UNIT of (string)
  | CONST of (string)
  | POSTFUNC of (string)
  | FUNC of (string)
  | COMPARISON of (string)
  | OP of (string)
  | SIGN of (string)
  | LBRACKET
  | RBRACKET
  | EOF of (int)
  | NEWLINE of (int)
  | STOP
  | IF
  | GOTO
  | SETUNDEFINED
  | ISDEFINED
  | ISUNDEFINED
  | QCODE
  | DECLARESTRING
  | STRVARPREFIX of (string)
  | VARPREFIX of (string)
  | EQSYMB
  | COMMENT of (string)
  | NUMBER of (float)
  | NATURAL of (int)
type tokenId = 
    | TOKEN_QUOTED
    | TOKEN_AXIS
    | TOKEN_TOOLOVERSIZE
    | TOKEN_MCOMMAND
    | TOKEN_MCODE
    | TOKEN_SCODE
    | TOKEN_FCODE
    | TOKEN_FUNIT
    | TOKEN_FMAX
    | TOKEN_FAUTO
    | TOKEN_POLAR
    | TOKEN_DRMINUS
    | TOKEN_DRPLUS
    | TOKEN_RADIUSCOMPENSATION
    | TOKEN_CHF
    | TOKEN_CC
    | TOKEN_C
    | TOKEN_CP
    | TOKEN_CR
    | TOKEN_CT
    | TOKEN_CTP
    | TOKEN_RND
    | TOKEN_FK
    | TOKEN_APPROACHSTRATEGY
    | TOKEN_LEN
    | TOKEN_R
    | TOKEN_CCA
    | TOKEN_APPR
    | TOKEN_DEP
    | TOKEN_LINE
    | TOKEN_LP
    | TOKEN_LN
    | TOKEN_LBL
    | TOKEN_REP
    | TOKEN_CALLLBL
    | TOKEN_POSX
    | TOKEN_PATTERNDEF
    | TOKEN_TOOLCALL
    | TOKEN_ENDPGM
    | TOKEN_COMMAND
    | TOKEN_DIVERSEFUNCTION
    | TOKEN_FN
    | TOKEN_COLON
    | TOKEN_UNIT
    | TOKEN_CONST
    | TOKEN_POSTFUNC
    | TOKEN_FUNC
    | TOKEN_COMPARISON
    | TOKEN_OP
    | TOKEN_SIGN
    | TOKEN_LBRACKET
    | TOKEN_RBRACKET
    | TOKEN_EOF
    | TOKEN_NEWLINE
    | TOKEN_STOP
    | TOKEN_IF
    | TOKEN_GOTO
    | TOKEN_SETUNDEFINED
    | TOKEN_ISDEFINED
    | TOKEN_ISUNDEFINED
    | TOKEN_QCODE
    | TOKEN_DECLARESTRING
    | TOKEN_STRVARPREFIX
    | TOKEN_VARPREFIX
    | TOKEN_EQSYMB
    | TOKEN_COMMENT
    | TOKEN_NUMBER
    | TOKEN_NATURAL
    | TOKEN_end_of_input
    | TOKEN_error
type nonTerminalId = 
    | NONTERM__startstart
    | NONTERM_start
    | NONTERM_header
    | NONTERM_eof
    | NONTERM_blocks
    | NONTERM_blockwithend
    | NONTERM_block
    | NONTERM_blockcontent
    | NONTERM_command
    | NONTERM_arguments
    | NONTERM_argument
    | NONTERM_linecontent
    | NONTERM_path
    | NONTERM_toolid
    | NONTERM_toolaxis
    | NONTERM_toolcalloptions
    | NONTERM_toolcalloption
    | NONTERM_pathdetails
    | NONTERM_line
    | NONTERM_linedetails
    | NONTERM_linepolar
    | NONTERM_approach
    | NONTERM_chamfer
    | NONTERM_round
    | NONTERM_circlecenter
    | NONTERM_circle
    | NONTERM_circlepolar
    | NONTERM_circlebyradius
    | NONTERM_circletangential
    | NONTERM_circletangentialpolar
    | NONTERM_directionrotation
    | NONTERM_coordinates
    | NONTERM_coordinate
    | NONTERM_polarcoordinates
    | NONTERM_polarcoordinate
    | NONTERM_feedrate
    | NONTERM_spindlespeed
    | NONTERM_mcommand
    | NONTERM_mcode
    | NONTERM_calllbl
    | NONTERM_lbl
    | NONTERM_optcomment
    | NONTERM_comment
    | NONTERM_varprefix
    | NONTERM_setvariable
    | NONTERM_value
    | NONTERM_id
    | NONTERM_op
    | NONTERM_op2
    | NONTERM_condition
    | NONTERM_patterndef
    | NONTERM_patterndefargs
    | NONTERM_patterndefarg
    | NONTERM_stop
/// This function maps tokens to integer indexes
val tagOfToken: token -> int

/// This function maps integer indexes to symbolic token ids
val tokenTagToTokenId: int -> tokenId

/// This function maps production indexes returned in syntax errors to strings representing the non terminal that would be produced by that production
val prodIdxToNonTerminal: int -> nonTerminalId

/// This function gets the name of a token as a string
val token_to_string: token -> string
val start : (FSharp.Text.Lexing.LexBuffer<'cty> -> token) -> FSharp.Text.Lexing.LexBuffer<'cty> -> (unit) 
