schema {
  query: Query
  mutation: Mutation
}

type Query {
  "Type of available op tasks for this customer"
  opTaskTypes: [String!]!
  "Get all the roles that may be assigned a task"
  opTaskRoles: [String!]!
  "Available units to set a dimension"
  dimensionUnits: [Unit!]!
  "Maintenance part references that already in the system"
  maintenancePartReferences: [String!]!
  "Get the machine groups that may be used by the op tasks"
  opTaskMachineGroups: [MachineGroupCategory!]!
  "Get all the op tasks"
  opTasks: [OpTask!]!
  "Get the op task for the specified ID"
  opTask(opTaskId: ID!): OpTask!
  "Op tasks by role"
  opTasksByRole(role: String!): [OpTask!]!
  "Op tasks by role and machine group"
  opTasksByRoleGroup(role: String!, machineGroup: String!): [OpTask!]!
  "Next actions for a specific role and a machine group"
  comingOpTaskActions(role: String!, machineGroup: String!): [OpTaskAction!]!
  "Return for a specific op task the last results (validations or errors)"
  lastOpTaskResults(opTaskId: ID!, number: Int): [OpTaskAction!]!
  "Return the op task actions that were completed in a specific range"
  opTaskResultsInRange (opTaskId: ID!, range: UtcDateTimeRange): [OpTaskAction!]!
}

type Mutation {
  createQualityTask(opTask: NewQualityTask!): QualityTask!
  createMaintenanceTask(opTask: NewMaintenanceTask!): MaintenanceTask!
  createAdviseDocTask(opTask: NewAdviseDocTask!): AdviseDocTask!
  createShiftChangeMessage(opTask: NewShiftChangeMessage!): ShiftChangeMessage!
  createAdviseShiftChange(opTask: NewAdviseShiftChange!): AdviseShiftChange!
  editQualityTask(opTask: UpdateQualityTask!): QualityTask!
  editMaintenanceTask(opTask: UpdateMaintenanceTask!): MaintenanceTask!
  editAdviseDocTask(opTask: UpdateAdviseDocTask!): AdviseDocTask!
  editShiftChangeMessage(opTask: UpdateShiftChangeMessage!): ShiftChangeMessage!
  editAdviseShiftChange(opTask: UpdateAdviseShiftChange!): AdviseShiftChange!
  validateOpTaskAction(validation: OpTaskActionValidation!): OpTaskAction!
  correctOpTaskActionValidation(validation: OpTaskActionValidation!): OpTaskAction!
  "Add a document to an op task that supports it"
  addDoc(opTaskId: ID!, docId: ID!): OpTask!
  "Remove a document from an op task that supports it"
  removeDoc (opTaskId: ID!, docId: ID!): OpTask!
}

type MachineGroupCategory {
  name: String!
  groups: [MachineGroup!]!
}

type MachineGroup {
  id: String!
  name: String!
  subGroups: [MachineGroup!]
}

enum OpTaskState {
  Draft
  Active
  Pause
  Archived
}

"Time of the day: hh:MM[:ss]"
scalar Time

enum WeekDay {
  Monday
  Tuesday
  Wednesday
  Thursday
  Friday
  Saturday
  Sunday
}

union Frequency = FixedDuration | FixedRange | MachiningDuration | MachiningRange | NumberOfParts | PartsRange | NumberOfCycles | CyclesRange | FixedTime | TimeRange | ShiftStart | ShiftEnd

type FixedDuration {
  seconds: Int!
}

type FixedRange {
  minSeconds: Int!
  maxSeconds: Int!
}

type MachiningDuration {
  seconds: Int!
}

type MachiningRange {
  minSeconds: Int!
  maxSeconds: Int!
}

type NumberOfParts {
  number: Int!
}

type PartsRange {
  min: Int!
  max: Int!
}

type NumberOfCycles {
  number: Int!
}

type CyclesRange {
  min: Int!
  max: Int!
}

type FixedTime {
  "Fixed time in the day"
  time: Time!
  "If not set: every week day"
  weekDay: [WeekDay!]
}

type TimeRange {
  "Week day of the start time"
  weekDay: [WeekDay!]
  start: Time!
  end: Time!
}

type ShiftStart {
  "Optional number of seconds after the shift start"
  seconds: Int
}

type ShiftEnd {
  "Optional number of seconds before the shift end"
  seconds: Int
}

input FrequencyInput {
  "Frequency type: FixedDuration | FixedRange | MachiningDuration | MachiningRange | NumberOfParts | PartsRange | NumberOfCycles | CyclesRange | FixedTime | TimeRange | ShiftStart | ShiftEnd"
  frequencyType: String!
  "Number of seconds in the case of FixedDuration, MachiningDuration, shiftStart, shiftEnd"
  seconds: Int
  "Minimum number of seconds in the case of FixedRange and machiningRange"
  minSeconds: Int
  "Maximum number of seconds in the case of FixedRange and MachiningRange"
  maxSeconds: Int
  "Number of parts in the case of NumberOfParts or NumberOfCycles"
  number: Int
  "Minimum number of parts in the case of PartsRange or CyclesRange"
  min: Int
  "Maximum number of parts in the case of PartsRange or CyclesRange"
  max: Int
  "week day of the start time in the case of TimeRange or FixedTime"
  weekDay: [WeekDay!]
  "Time in the case of FixedTime"
  time: Time
  "Start time in the case of TimeRange"
  start: Time
  "End time in the case of TimeRange"
  end: Time
}

interface IOpTask {
  id: ID!
  state: OpTaskState!
  name: String!
  description: String
  machineGroup: String!
  frequency: Frequency!
  "Who is responsible of the task: Operator, Maintenance, ..."
  role: String!
}

union OpTask = QualityTask | MaintenanceTask | ShiftChangeMessage | AdviseShiftChange | AdviseDocTask

enum CommentRequirement {
  None
  Mandatory
  Optional
}

"Interface to create a new op task. By default, it is active at creation"
interface INewOpTask {
  name: String!
  description: String
  machineGroup: String!
  frequency: Frequency!
  "Who is responsible of the task: Operator, Maintenance, ..."
  role: String!
}

interface IUpdateOpTask {
  id: ID!
  "If null: leave unchanged"
  state: OpTaskState
  "If null: leave unchanged"
  name: String
  "If null: leave unchanged"
  description: String
  "If null: leave unchanged"
  frequency: Frequency
}

enum Unit {
  Mm
  Micro
  Inch
}

type Dimension {
  id: ID!
  name: String!
  value: Float!
  unit: Unit
  tolerancePlus: Float!
  toleranceMinus: Float!
  numberOfParts: Int!
  description: String
}

input DimensionInput {
  "Only for existing dimensions"
  id: ID
  name: String!
  value: Float!
  unit: Unit
  tolerancePlus: Float!
  toleranceMinus: Float!
  numberOfParts: Int!
  description: String
}

type QualityTask implements IOpTask {
  id: ID!
  state: OpTaskState!
  name: String!
  description: String
  machineGroup: String!
  frequency: Frequency!
  "Who is responsible of the task: Operator, Maintenance, ..."
  role: String!
  commentRequirement: CommentRequirement!
  dimensions: [Dimension!]
  docs: [Doc!]!
}

input NewQualityTask {
  name: String!
  description: String
  machineGroup: String!
  frequency: FrequencyInput!
  "Who is responsible of the task: Operator, Maintenance, ..."
  role: String!
  commentRequirement: CommentRequirement!
  dimensions: [DimensionInput!]  
  docIds: [ID!]!
}

input UpdateQualityTask {
  id: ID!
  state: OpTaskState
  "If null: leave unchanged"
  name: String
  "If null: leave unchanged"
  description: String
  "If null: leave unchanged"
  frequency: FrequencyInput
  commentRequirement: CommentRequirement
  dimensions: [DimensionInput!]
}

type MaintenanceTask implements IOpTask {
  id: ID!
  state: OpTaskState!
  name: String!
  description: String
  machineGroup: String!
  frequency: Frequency!
  "Who is responsible of the task: Operator, Maintenance, ..."
  role: String!
  commentRequirement: CommentRequirement!
  partReference: String
}

input NewMaintenanceTask {
  name: String!
  description: String
  machineGroup: String!
  frequency: FrequencyInput!
  "Who is responsible of the task: Operator, Maintenance, ..."
  role: String!
  commentRequirement: CommentRequirement!
  partReference: String
  docIds: [ID!]!
}

input UpdateMaintenanceTask {
  id: ID!
  state: OpTaskState
  "If null: leave unchanged"
  name: String
  "If null: leave unchanged"
  description: String
  "If null: leave unchanged"
  frequency: FrequencyInput
  commentRequirement: CommentRequirement
  partReference: String
}

"""
To allow an operator to leave a message at the end of this shift to the next operator
"""
type ShiftChangeMessage implements IOpTask {
  id: ID!
  state: OpTaskState!
  name: String!
  description: String
  machineGroup: String!
  frequency: Frequency!
  "Who is responsible of the task: Operator, Maintenance, ..."
  role: String!
  docs: [Doc!]!
}

input NewShiftChangeMessage {
  name: String!
  description: String
  machineGroup: String!
  frequency: FrequencyInput!
  "Who is responsible of the task: Operator, Maintenance, ..."
  role: String!
  docIds: [ID!]!
}

input UpdateShiftChangeMessage {
  id: ID!
  state: OpTaskState
  "If null: leave unchanged"
  name: String
  "If null: leave unchanged"
  description: String
  "If null: leave unchanged"
  frequency: FrequencyInput
}

"""
To let an operator advice he read the shift change message from the previous operator
"""
type AdviseShiftChange implements IOpTask {
  id: ID!
  state: OpTaskState!
  name: String!
  description: String
  machineGroup: String!
  frequency: Frequency!
  "Who is responsible of the task: Operator, Maintenance, ..."
  role: String!
}

input NewAdviseShiftChange {
  name: String!
  description: String
  machineGroup: String!
  frequency: FrequencyInput!
  "Who is responsible of the task: Operator, Maintenance, ..."
  role: String!
}

input UpdateAdviseShiftChange {
  id: ID!
  state: OpTaskState
  "If null: leave unchanged"
  name: String
  "If null: leave unchanged"
  description: String
  "If null: leave unchanged"
  frequency: FrequencyInput
}

type Doc {
  id: ID!
  path: String!
  version: Int
}

"""
To ask the operator to take note of any new documentation for its machine or operation
"""
type AdviseDocTask implements IOpTask {
  id: ID!
  state: OpTaskState!
  name: String!
  description: String
  machineGroup: String!
  frequency: Frequency!
  "Who is responsible of the task: Operator, Maintenance, ..."
  role: String!
  doc: Doc!
}

input NewAdviseDocTask {
  name: String!
  description: String
  machineGroup: String!
  frequency: FrequencyInput!
  "Who is responsible of the task: Operator, Maintenance, ..."
  role: String!
  docId: ID!
}

input UpdateAdviseDocTask {
  id: ID!
  state: OpTaskState
  "If null: leave unchanged"
  name: String
  "If null: leave unchanged"
  description: String
  "If null: leave unchanged"
  frequency: FrequencyInput
}

"UTC DateTime: YYYYmmddTHHmmssZ"
scalar UtcDateTime
"UTC Date/time range: [YYYYmmddTHHmssZ-YYYYmmddTHHmmssZ)"
scalar UtcDateTimeRange

enum OpTaskActionCompletion {
  Validated
  Error
}

"If no result is set, according to the start and end date/times, the state of the action is To come / To do / Late"
type OpTaskAction {
  id: ID!
  machineId: ID!
  opTask: OpTask!
  start: UtcDateTime
  end: UtcDateTime
  result: OpTaskActionResult
}

union OpTaskActionResult = QualityResult | MaintenanceResult | ShiftChangeResult | AdviseShiftChangeResult | AdviseDocResult

interface IOpTaskActionResult {
  dateTime: UtcDateTime!
  completion: OpTaskActionCompletion!
}

type Measure {
  dimensionId: ID!
  value: Float!
}

input MeasureInput {
  dimensionId: ID!
  value: Float!
}

type QualityResult implements IOpTaskActionResult {
  dateTime: UtcDateTime!
  completion: OpTaskActionCompletion!
  comment: String
  measures: [Measure!]!
}

type MaintenanceResult implements IOpTaskActionResult {
  dateTime: UtcDateTime!
  completion: OpTaskActionCompletion!
  comment: String
}

type ShiftChangeResult implements IOpTaskActionResult {
  dateTime: UtcDateTime!
  completion: OpTaskActionCompletion!
  comment: String!
}

type AdviseShiftChangeResult implements IOpTaskActionResult {
  dateTime: UtcDateTime!
  completion: OpTaskActionCompletion!
}

type AdviseDocResult implements IOpTaskActionResult {
  dateTime: UtcDateTime!
  completion: OpTaskActionCompletion!
}

input OpTaskActionValidation {
  id: ID!
  completion: OpTaskActionCompletion
  "Only when applicable"
  comment: String
  "For Quality validation"
  measures: [MeasureInput!]
}
