// Copyright (C) 2009-2023 Lemoine Automation Technologies
//
// SPDX-License-Identifier: Apache-2.0

using System;
using System.Windows.Forms;

namespace Lemoine.BaseControls
{
  /// <summary>
  /// A Tri-State TreeView designed for on-demand populating of the tree
  /// 'Mixed' nodes retain their checked state, meaning they can be checked or unchecked according to their current state
  /// Tree can be navigated by keyboard (cursor keys and space)
  /// No need to do anything special in calling code
  /// 
  /// This class is internal: if you want to use a treeview choose "customtreeview" which
  /// combines this tristate with a single selection treeview
  /// 
  /// If "NodeIsSelectable" of TreeViewWithBuilder is true, the selection of a node (having at least one child) will not
  /// be propagated to the children since nodes are considered as independent entities and not just as a global container
  /// for the children. There are thus two different behaviours to understand.
  /// </summary>
  internal class TreeViewTriState : TreeViewWithBuilder
  {
    #region Enums
    /// <summary>
    /// CheckedState is an enum of all allowable nodes states
    /// </summary>
    enum CheckedState : int
    {
      UnInitialised = -1,
      UnChecked,
      Checked,
      Mixed
    };
    #endregion
    
    #region Members
    bool m_emitCheckboxChangedEnabled = true;
    
    /// <summary>
    /// IgnoreClickAction is used to ignore messages generated by setting the node. Checked flag in code
    /// Do not set <c>e.Cancel = true</c> in <c>OnBeforeCheck</c> otherwise the Checked state will be lost
    /// </summary>
    int IgnoreClickAction = 0;
    #endregion

    #region Constructors
    /// <summary>
    /// Default constructor. Create and populate an image list
    /// </summary>
    public TreeViewTriState() : base()
    {
      StateImageList = new ImageList();

      // populate the image list, using images from the System.Windows.Forms.CheckBoxRenderer class
      for (int i = 0; i < 3; i++)
      {
        // Create a bitmap which holds the relevent check box style
        // see http://msdn.microsoft.com/en-us/library/ms404307.aspx and
        // http://msdn.microsoft.com/en-us/library/system.windows.forms.checkboxrenderer.aspx

        var bmp = new System.Drawing.Bitmap(16, 16);
        System.Drawing.Graphics chkGraphics = System.Drawing.Graphics.FromImage(bmp);
        switch (i)
        {
            // 0,1 - offset the checkbox slightly so it positions in the correct place
          case 0:
            CheckBoxRenderer.DrawCheckBox(chkGraphics, new System.Drawing.Point(0, 1),
                                          System.Windows.Forms.VisualStyles.CheckBoxState.UncheckedNormal);
            break;
          case 1:
            CheckBoxRenderer.DrawCheckBox(chkGraphics, new System.Drawing.Point(0, 1),
                                          System.Windows.Forms.VisualStyles.CheckBoxState.CheckedNormal);
            break;
          case 2:
            CheckBoxRenderer.DrawCheckBox(chkGraphics, new System.Drawing.Point(0, 1),
                                          System.Windows.Forms.VisualStyles.CheckBoxState.MixedNormal);
            break;
        }

        StateImageList.Images.Add(bmp);
      }
    }
    #endregion
    
    #region Reactions
    /// <summary>
    /// Called when a tree node is added
    /// Only used to initialize the checkbox for the root nodes
    /// </summary>
    /// <param name="node"></param>
    protected internal override void OnTreeNodeAdded(TreeNode node)
    {
      if (this.Nodes.Contains(node)) {
        node.StateImageIndex = 0;
      }
    }

    /// <summary>
    /// Called once before window displayed. Disables default Checkbox functionality and ensures all nodes display an 'unchecked' image.
    /// </summary>
    protected override void OnCreateControl()
    {
      base.OnCreateControl();
      CheckBoxes = false;			// Disable default CheckBox functionality if it's been enabled

      // Give every node an initial 'unchecked' image
      m_emitCheckboxChangedEnabled = false;
      IgnoreClickAction++;	// we're making changes to the tree, ignore any other change requests
      UpdateChildState(this.Nodes, (int)CheckedState.UnChecked, false, true);
      IgnoreClickAction--;
      m_emitCheckboxChangedEnabled = true;
    }

    /// <summary>
    /// Called after a node is checked.
    /// Forces all children to inherit current state
    /// Notifies parents they may need to become 'mixed', 'checked' or 'unchecked'
    /// </summary>
    /// <param name="e"></param>
    protected override void OnAfterCheck(TreeViewEventArgs e)
    {
      base.OnAfterCheck(e);
      
      if (IgnoreClickAction > 0)
      {
        return;
      }

      IgnoreClickAction++;	// we're making changes to the tree, ignore any other change requests

      // the checked state has already been changed, we just need to update the state index

      // node is either ticked or unticked. ignore mixed state, as the node is still only ticked or unticked regardless of state of children
      System.Windows.Forms.TreeNode tn = e.Node;
      tn.StateImageIndex = tn.Checked ? (int)CheckedState.Checked : (int)CheckedState.UnChecked;

      if (!NodeIsSelectable) {
        // force all children to inherit the same state as the current node
        UpdateChildState(e.Node.Nodes, e.Node.StateImageIndex, e.Node.Checked, false);

        // populate state up the tree, possibly resulting in parents with mixed, checked or unchecked state
        UpdateParentState(e.Node.Parent);
      }

      IgnoreClickAction--;
      
      if (m_emitCheckboxChangedEnabled) {
        EmitSelectionChanged ();
      }
    }
    
    /// <summary>
    /// Behaviour after a node is selected
    /// </summary>
    /// <param name="e"></param>
    protected override void OnAfterSelect(TreeViewEventArgs e)
    {
      // Do nothing here: selection is done by checking boxes
    }

    /// <summary>
    /// Called after a node is expanded. Ensures any new nodes display an 'unchecked' image
    /// </summary>
    /// <param name="e"></param>
    protected override void OnAfterExpand(TreeViewEventArgs e)
    {
      // If any child node is new, give it the same check state as the current node
      // So if current node is ticked, child nodes will also be ticked
      base.OnAfterExpand(e);
      
      m_emitCheckboxChangedEnabled = false;
      IgnoreClickAction++; // we're making changes to the tree, ignore any other change requests
      UpdateChildState(e.Node.Nodes, e.Node.StateImageIndex, e.Node.Checked, true);
      IgnoreClickAction--;
      m_emitCheckboxChangedEnabled = true;
    }
    
    /// <summary>
    /// Called on keypress. Used to change node state when Space key is pressed
    /// Invokes OnAfterCheck to do the real work
    /// </summary>
    /// <param name="e"></param>
    protected override void OnKeyDown(KeyEventArgs e)
    {
      base.OnKeyDown(e);

      // is the keypress a space? If not, discard it
      if (e.KeyCode == System.Windows.Forms.Keys.Space)
      {
        // toggle the node's checked status. This will then fire OnAfterCheck
        SelectedNode.Checked = !SelectedNode.Checked;
      }
    }

    /// <summary>
    /// Called when node is clicked by the mouse. Does nothing unless the image was clicked
    /// Invokes OnAfterCheck to do the real work
    /// </summary>
    /// <param name="e"></param>
    protected override void OnNodeMouseClick(TreeNodeMouseClickEventArgs e)
    {
      base.OnNodeMouseClick(e);

      // is the click on the checkbox?  If not, discard it
      System.Windows.Forms.TreeViewHitTestInfo info = HitTest(e.X, e.Y);
      if (info == null || info.Location != System.Windows.Forms.TreeViewHitTestLocations.StateImage)
      {
        return;
      }
      
      // toggle the node's checked status. This will then fire OnAfterCheck
      System.Windows.Forms.TreeNode tn = e.Node;
      tn.Checked = !tn.Checked;
    }
    #endregion

    #region Methods
    // <summary>
    // Helper function to replace child state with that of the parent
    // </summary>
    private void UpdateChildState(TreeNodeCollection nodes, int StateImageIndex, bool Checked, bool ChangeUninitialisedNodesOnly)
    {
      foreach (System.Windows.Forms.TreeNode tnChild in nodes)
      {
        if (!ChangeUninitialisedNodesOnly || tnChild.StateImageIndex == -1)
        {
          tnChild.StateImageIndex = StateImageIndex;
          tnChild.Checked = Checked;	// override 'checked' state of child with that of parent

          if (tnChild.Nodes.Count > 0)
          {
            UpdateChildState(tnChild.Nodes, StateImageIndex, Checked, ChangeUninitialisedNodesOnly);
          }
        }
      }
    }

    // <summary>
    // Helper function to notify parent it may need to use 'mixed' state
    // </summary>
    private void UpdateParentState(TreeNode tn)
    {
      // Node needs to check all of it's children to see if any of them are ticked or mixed
      if (tn == null) {
        return;
      }

      int OrigStateImageIndex = tn.StateImageIndex;

      int UnCheckedNodes = 0, CheckedNodes = 0, MixedNodes = 0;

      // The parent needs to know how many of it's children are Checked or Mixed
      foreach (System.Windows.Forms.TreeNode tnChild in tn.Nodes)
      {
        if (tnChild.StateImageIndex == (int)CheckedState.Checked) {
          CheckedNodes++;
        }
        else if (tnChild.StateImageIndex == (int)CheckedState.Mixed)
        {
          MixedNodes++;
          break;
        }
        else {
          UnCheckedNodes++;
        }
      }

      // If all child nodes are checked then parent is checked
      // If at least one child is unchecked, then parent is unchecked
      if (MixedNodes == 0)
      {
        if (UnCheckedNodes == 0)
        {
          // all children are checked, so parent must be checked
          tn.Checked = true;
        }
        else
        {
          // at least one child is unchecked, so parent must be unchecked
          tn.Checked = false;
        }
      }

      // Determine the parent's new Image State
      if (MixedNodes > 0)
      {
        // at least one child is mixed, so parent must be mixed
        tn.StateImageIndex = (int)CheckedState.Mixed;
      }
      else if (CheckedNodes > 0 && UnCheckedNodes == 0)
      {
        // all children are checked
        if (tn.Checked) {
          tn.StateImageIndex = (int)CheckedState.Checked;
        }
        else {
          tn.StateImageIndex = (int)CheckedState.Mixed;
        }
      }
      else if (CheckedNodes > 0)
      {
        // some children are checked, the rest are unchecked
        tn.StateImageIndex = (int)CheckedState.Mixed;
      }
      else
      {
        // all children are unchecked
        if (tn.Checked) {
          tn.StateImageIndex = (int)CheckedState.Mixed;
        }
        else {
          tn.StateImageIndex = (int)CheckedState.UnChecked;
        }
      }

      if (OrigStateImageIndex != tn.StateImageIndex && tn.Parent != null)
      {
        // Parent's state has changed, notify the parent's parent
        UpdateParentState(tn.Parent);
      }
    }
    
    /// <summary>
    /// Return true if the node is selected
    /// </summary>
    /// <param name="node">node to check</param>
    /// <returns></returns>
    protected override bool IsSelected(TreeNode node)
    {
      return node.Checked;
    }
    
    /// <summary>
    /// Select a node
    /// </summary>
    /// <param name="node">node to select</param>
    protected override void Select(TreeNode node)
    {
      m_emitCheckboxChangedEnabled = false;
      node.Checked = true;
      m_emitCheckboxChangedEnabled = true;
    }
    
    /// <summary>
    /// Deselect all nodes
    /// </summary>
    protected override void ClearSelection()
    {
      m_emitCheckboxChangedEnabled = false;
      Deselect(this.Nodes);
      this.SelectedNode = null;
      m_emitCheckboxChangedEnabled = true;
    }
    
    void Deselect(TreeNodeCollection nodes)
    {
      foreach (TreeNode node in nodes) {
        Deselect(node.Nodes);
        node.Checked = false;
      }
    }
    #endregion
  }
}
