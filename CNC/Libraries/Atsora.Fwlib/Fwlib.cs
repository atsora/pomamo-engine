// Copyright (C) 2009-2023 Atsora Solutions

using System;
using System.Runtime.InteropServices;
using System.Text;

namespace Atsora.Fwlib
{
  /// <summary>
  /// Fanuc error codes
  /// </summary>
  public enum EW
  {
    /// <summary>
    /// protocol error
    /// </summary>
    PROTOCOL = -17,
    /// <summary>
    /// Windows socket error
    /// </summary>
    SOCKET = -16,
    /// <summary>
    /// DLL not exist error
    /// </summary>
    NODLL = -15,
    /// <summary>
    /// error in APi library initial validfile
    /// </summary>
    INIERR = -14,
    /// <summary>
    /// low temperature alarm of intelligent terminal
    /// </summary>
    ITLOW = -13,
    /// <summary>
    /// hight temperature alarm of itelligent terminal
    /// </summary>
    ITHIGHT = -12,
    /// <summary>
    /// bus error
    /// </summary>
    BUS = -11,
    /// <summary>
    /// system error
    /// </summary>
    SYSTEM2 = -10,
    /// <summary>
    /// hssb communication error
    /// </summary>
    HSSB = -9,
    /// <summary>
    /// Windows library handle error
    /// </summary>
    HANDLE = -8,
    /// <summary>
    /// CNC/PMC version mismatch
    /// </summary>
    VERSION = -7,
    /// <summary>
    /// abnormal error
    /// </summary>
    UNEXP = -6,
    /// <summary>
    /// system error
    /// </summary>
    SYSTEM = -5,
    /// <summary>
    /// shared RAM parity error
    /// </summary>
    PARITY = -4,
    /// <summary>
    /// emm386 or mmcsys install error
    /// </summary>
    MMCSYS = -3,
    /// <summary>
    /// reset or stop occured error
    /// </summary>
    RESET = -2,
    /// <summary>
    /// busy error
    /// </summary>
    BUSY = -1,
    /// <summary>
    /// no problem
    /// </summary>
    OK = 0,
    /// <summary>
    /// One of the following errors:
    /// <entry>command prepare error</entry>
    /// <entry>pmc not exist</entry>
    /// </summary>
    FUNC_NOPMC = 1,
    /// <summary>
    /// data block length error
    /// </summary>
    LENGTH = 2,
    /// <summary>
    /// One of the following errors:
    /// <entry>data number error</entry>
    /// <entry>address range error</entry>
    /// </summary>
    NUMBER_RANGE = 3,
    /// <summary>
    /// One of the following errors:
    /// <entry>data attribute error</entry>
    /// <entry>data type error</entry>
    /// </summary>
    ATTRIB_TYPE = 4,
    /// <summary>
    /// data error
    /// </summary>
    DATA = 5,
    /// <summary>
    /// no option error
    /// </summary>
    NOOPT = 6,
    /// <summary>
    /// write protect error
    /// </summary>
    PROT = 7,
    /// <summary>
    /// memory overflow error
    /// </summary>
    OVRFLOW = 8,
    /// <summary>
    /// cnc parameter not correct error
    /// </summary>
    PARAM = 9,
    /// <summary>
    /// buffer error
    /// </summary>
    BUFFER = 10,
    /// <summary>
    /// path error
    /// </summary>
    PATH = 11,
    /// <summary>
    /// cnc mode error
    /// </summary>
    MODE = 12,
    /// <summary>
    /// execution rejected error
    /// </summary>
    REJECT = 13,
    /// <summary>
    /// data server error
    /// </summary>
    DTSRVR = 14,
    /// <summary>
    /// alarm has been occurred
    /// </summary>
    ALARM = 15,
    /// <summary>
    /// CNC is not running
    /// </summary>
    STOP = 16,
    /// <summary>
    /// protection data error
    /// </summary>
    PASSWD = 17,
    /// <summary>
    /// error generated by PMC
    /// </summary>
    PMC = 18,
    /// <summary>
    /// PMC handle error
    /// </summary>
    PMCHANDLE = 19
  };

  /// <summary>
  /// Fanuc Automatic modes for version 15 in cnc_statinfo
  /// </summary>
  public enum AUTO15
  {
    /// <summary>
    /// No selection
    /// </summary>
    NO_SELECT = 0,
    /// <summary>
    /// Manual data input/MDI operation.
    /// </summary>
    MDI = 1,
    /// <summary>
    /// Tape mode
    /// </summary>
    TAPE = 2,
    /// <summary>
    /// Automatic operation (memory operation).
    /// </summary>
    MEMORY = 3,
    /// <summary>
    /// Edit mode
    /// </summary>
    EDIT = 4,
    /// <summary>
    /// Teachin mode
    /// </summary>
    TEACHIN = 5
  };

  /// <summary>
  /// Fanuc manual modes for version 15 in cnc_statinfo
  /// </summary>
  public enum MANUAL15
  {
    /// <summary>
    /// No selection
    /// </summary>
    NO_SELECT = 0,
    /// <summary>
    /// Reference
    /// </summary>
    REFERENCE = 1,
    /// <summary>
    /// Inc_feed mode
    /// </summary>
    INC_FEED = 2,
    /// <summary>
    /// Handle mode
    /// </summary>
    HANDLE = 3,
    /// <summary>
    /// Jog mode
    /// </summary>
    JOG = 4,
    /// <summary>
    /// Angular jog mode
    /// </summary>
    ANGULAR_JOG = 5,
    /// <summary>
    /// Inc_handle mode
    /// </summary>
    INC_HANDLE = 6,
    /// <summary>
    /// Jog handle mode
    /// </summary>
    JOG_HANDLE = 7
  };

  /// <summary>
  /// Fanuc automatic or manual modes for versions 16 and 16W in cnc_statinfo
  /// </summary>
  public enum AUTO16
  {
    /// <summary>
    /// Manual data input/MDI operation.
    /// </summary>
    MDI = 0,
    /// <summary>
    /// Automatic operation (memory operation).
    /// </summary>
    MEMORY = 1,
    NO_SELECT = 2,
    /// <summary>
    /// Program editing.
    /// </summary>
    EDIT = 3,
    /// <summary>
    /// Manual handle feed mode.
    /// </summary>
    HANDLE = 4,
    /// <summary>
    /// Jog feed.
    /// </summary>
    JOG = 5,
    /// <summary>
    /// Teaching in jog feed mode.
    /// </summary>
    TEACHIN_JOG = 6,
    /// <summary>
    /// Teaching in handle feed mode.
    /// </summary>
    TEACHIN_HANDLE = 7,
    /// <summary>
    /// Incremental feed mode = step feed.
    /// </summary>
    INC_FEED = 8,
    /// <summary>
    /// Reference position return.
    /// </summary>
    REFERENCE = 9,
    /// <summary>
    /// Remote operation.
    /// </summary>
    REMOTE = 10,
    TEST = 11
  };

  /// <summary>
  /// Fanuc running statuses for version 15 in cnc_statinfo
  /// </summary>
  public enum RUN15
  {
    /// <summary>
    /// Automatic operation has stopped.
    /// </summary>
    STOP = 0,
    /// <summary>
    /// Automatic operation has been suspended
    /// </summary>
    HOLD = 1,
    /// <summary>
    /// Automatic operation has started (and program execution is under way)
    /// </summary>
    START = 2,
    /// <summary>
    /// The tool is returning or being repositioned when the tool retract and return function is executed
    /// </summary>
    MSTR = 3,
    RESTART = 4,
    PRSR = 5,
    NSRC = 6,
    RESTART2 = 7,
    RESET = 8,
    HPCC = 13
  };

  /// <summary>
  /// Fanuc running statuses for version 16 in cnc_statinfo
  /// </summary>
  public enum RUN16
  {
    RESET = 0,
    STOP = 1,
    /// <summary>
    /// Automatic operation has been suspended
    /// </summary>
    HOLD = 2,
    /// <summary>
    /// Automatic operation has started (and program execution is under way)
    /// </summary>
    START = 3,
    /// <summary>
    /// The tool is returning or being repositioned when the tool retract and return function is executed
    /// </summary>
    MSTR = 4
  };

  /// <summary>
  /// Fanuc running statuses for version 16W in cnc_statinfo
  /// </summary>
  public enum RUN16W
  {
    NOT_READY = 0,
    M_READY = 1,
    /// <summary>
    /// Automatic operation has started (and program execution is under way)
    /// </summary>
    C_START = 2,
    /// <summary>
    /// Automatic operation has been suspended
    /// </summary>
    F_HOLD = 3,
    /// <summary>
    /// Automatic operation has stopped.
    /// </summary>
    B_STOP = 4
  };

  /// <summary>
  /// Fanuc motion status for version 15 in cnc_statinfo
  /// </summary>
  public enum MOTION15
  {
    NOTHING = 0,
    MOTION = 1,
    DWELL = 2,
    WAIT = 3
  }

  /// <summary>
  /// Fanuc motion status for versions 16 and 16W in cnc_statinfo
  /// </summary>
  public enum MOTION16
  {
    NOTHING = 0,
    /// <summary>
    /// Program-specified axis movement is under way.
    /// </summary>
    MOTION = 1,
    /// <summary>
    /// Program-specified dwell command (G04) is being executed.
    /// </summary>
    DWELL = 2
  }

  /// <summary>
  /// cnc_sysinfo:read CNC system information
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct ODBSYS
  {
    public byte addinfo1;           /* additional information */
    public byte addinfo2;           /* model information */
    public Int16 max_axis;          /* maximum axis number */
    [MarshalAs (UnmanagedType.ByValArray, SizeConst = 2)]
    public char[] cnc_type; /* cnc type <ascii char> */
    [MarshalAs (UnmanagedType.ByValArray, SizeConst = 2)]
    public char[] mt_type;   /* M/T/TT <ascii char> */
    [MarshalAs (UnmanagedType.ByValArray, SizeConst = 4)]
    public char[] series;   /* series NO. <ascii char> */
    [MarshalAs (UnmanagedType.ByValArray, SizeConst = 4)]
    public char[] version;  /* version NO. <ascii char> */
    [MarshalAs (UnmanagedType.ByValArray, SizeConst = 2)]
    public char[] axes;     /* axis number <ascii char> */
  }

  /// <summary>
  /// cnc_actf:read actual axis feedrate(F)
  /// cnc_acts:read actual spindle speed(S)
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct ODBACT
  {
    [MarshalAs (UnmanagedType.ByValArray, SizeConst = 2)]
    public Int16[] dummy;     /* dummy */
    public int data;      /* actual feed / actual spindle */
  };

  /// <summary>
  /// cnc_rdposition:read tool position
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct POSELM
  {
    public int data;       /* position data */
    public Int16 dec;        /* decimal position */
    public Int16 unit;       /* data unit */
    public Int16 disp;       /* display flag */
    public char name;       /* axis name */
    public char suff;       /* suffix */
  };

  /// <summary>
  /// Position
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct ODBPOS_data
  {
    public POSELM abs;        /* absolute position */
    public POSELM mach;       /* machine position */
    public POSELM rel;        /* relative position */
    public POSELM dist;       /* distance position */
  };


  /* cnc_rdpdf_subdirn:read file count the directory has */
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public class ODBPDFNFIL
  {
    public Int16 dir_num;    /* directory */
    public Int16 file_num;   /* file */
  }

  /// <summary>
  /// 10 positions
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct ODBPOS
  {
    [MarshalAs (UnmanagedType.ByValArray, SizeConst = 10)]
    public ODBPOS_data[] position;
  };


  /// <summary>
  /// cnc_statinfo:read CNC status information
  /// for FS15D or FS15BD
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct ODBST_150
  {
    [MarshalAs (UnmanagedType.ByValArray, SizeConst = 2)]
    public Int16[] dummy;      /* dummy                    */
    public Int16 aut;          /* selected automatic mode  */
    public Int16 manual;       /* selected manual mode     */
    public Int16 run;          /* running status           */
    public Int16 edit;         /* editting status          */
    public Int16 motion;       /* axis, dwell status       */
    public Int16 mstb;         /* m, s, t, b status        */
    public Int16 emergency;    /* emergency stop status    */
    public Int16 write;        /* writting status          */
    public Int16 labelskip;    /* label skip status        */
    public Int16 alarm;        /* alarm status             */
    public Int16 warning;      /* warning status           */
    public Int16 battery;      /* battery status           */
  };

  /// <summary>
  /// cnc_statinfo:read CNC status information
  /// for all controls except FS15D, FS15BD and FS16WD
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct ODBST
  {
    public Int16 hdck;      /* handl retrace status */
    public Int16 tmmode;    /* T/M mode */
    public Int16 aut;       /* selected automatic mode */
    public Int16 run;       /* running status */
    public Int16 motion;    /* axis, dwell status */
    public Int16 mstb;      /* m, s, t, b status */
    public Int16 emergency; /* emergency stop status */
    public Int16 alarm;     /* alarm status */
    public Int16 edit;      /* editting status */
  };

  /// <summary>
  /// cnc_rdspmeter:read spindle load meter
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct LOADELM
  {
    public int data;       /* load meter */
    public Int16 dec;        /* decimal position */
    public Int16 unit;       /* unit */
    public byte name;       /* name of data */
    public byte suff1;      /* suffix */
    public byte suff2;      /* suffix */
    public byte reserve;    /* reserve */
  };

  /// <summary>
  /// Spindle load and spindle speed
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct ODBSPLOAD
  {
    public LOADELM spload;     /* spindle load meter */
    public LOADELM spspeed;    /* spindle speed */
  };

  /// <summary>
  /// cnc_rdprgnumo8: read program number under execution
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct ODBPROO8
  {
    [MarshalAs (UnmanagedType.ByValArray, SizeConst = 2)]
    public Int16[] dummy;      /* dummy                    */
    public int data;           /* running program number */
    public int mdata;          /* main program number*/
  }

  /// <summary>
  /// cnc_rdtofs: read tool offset value
  /// cnc_wrtofs: write tool offset value
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct ODBTOFS
  {
    public Int16 datano;       /* data number */
    public Int16 type;         /* data type */
    public int data;           /* data */
  }

  /// <summary>
  /// cnc_rdtofsr: read tool offset values
  /// 
  /// To be used only when m_ofs or t_ofs is used
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct IODBTO_M_T_OFS
  {
    public Int16 datano_s;     /* start offset number */
    public Int16 type;         /* data type */
    public Int16 datano_e;     /* end offset number */
    [MarshalAs (UnmanagedType.ByValArray, SizeConst = 128)]
    public int[] m_t_ofs;        /* data */
  }

  /// <summary>
  /// cnc_wrtofsr: write tool offset values
  /// 
  /// To be used only when m_ofs or t_ofs is used
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public class IODBTO_M_T_OFS_W
  {
    public Int16 datano_s;     /* start offset number */
    public Int16 type;         /* data type */
    public Int16 datano_e;     /* end offset number */
    [MarshalAs (UnmanagedType.ByValArray, SizeConst = 128)]
    public int[]? m_t_ofs;        /* data */
  }

  /// <summary>
  /// cnc_rdzofs: read work zero offset value
  /// cnc_wrzofs: write work zero offset value
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct IODBZOFS
  {
    public Int16 datano;       /* offset NO. */
    public Int16 type;         /* axis number */
    public int data;           /* data value */
  }

  /// <summary>
  /// cnc_rdmacro: read custom macro variable
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct ODBM
  {
    public Int16 datano;    /* variable number */
    public Int16 dummy;     /* dummy */
    public int mcr_val;   /* macro variable */
    public Int16 dec_val;   /* decimal point */
  };

  /// <summary>
  /// cnc_rdmacror3: read custom macro names (area specified)
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct IODBMRN3
  {
    public double mcr_val; /* macro variable */
    [MarshalAs (UnmanagedType.ByValTStr, SizeConst = 32)]
    public string name;    /* macro name */
  };

  /// <summary>
  /// cnc_rdmacror: read custom macro names (area specified)
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct IODBMR_data
  {
    public int mcr_val;        // value of custom macro var
    public Int16 dec_val;      // number of places of decimals
    public Int16 _dummy;
  }

  /// <summary>
  /// 40 IODBMR_data
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct IODBMR
  {
    public Int16 datano_s;
    public Int16 _dummy1;
    public Int16 datano_e;
    public Int16 _dummy2;

    [MarshalAs (UnmanagedType.ByValArray, SizeConst = 40)]
    public IODBMR_data[] iodbmr;
  };

  /// <summary>
  /// cnc_rdparainfo:read informations of CNC parameter
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct ODBPARAIF
  {
    /// <summary>
    /// Number of parameter information.
    /// Number of the parameter information which has been read actually.
    /// </summary>
    public UInt16 info_no; /* number of parameter information */
    /// <summary>
    /// Previous parameter number
    /// Previous effective number of parameter information which has been read first.
    /// </summary>
    public Int16 prev_no; /* previous parameter number */
    /// <summary>
    /// Next parameter number
    /// Next effective number of parameter information which has been read last.
    /// </summary>
    public Int16 next_no; /* next parameter number */
    /// <summary>
    /// Parameter number
    /// Parameter number which exists actually.
    /// </summary>
    public Int16 prm_no; /* parameter number */
    /// <summary>
    /// Attribute of parameter
    /// </summary>
    public Int16 prm_type; /* attribute of parameter */
  }; // In the case where the number of data is 1

  /// <summary>
  /// cnc_rdparam:read parameter
  /// cnc_wrparam:write parameter
  /// cnc_rdset:read setting data
  /// cnc_wrset:write setting data
  /// cnc_rdparar:read parameter(area specified)
  /// cnc_wrparas:write parameter(plural specified)
  /// cnc_rdsetr:read setting data(area specified)
  /// cnc_wrsets:write setting data(plural specified)
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct IODBPSD_C
  {
    /// <summary>
    /// parameter number
    /// </summary>
    public Int16 datano;
    /// <summary>
    /// upper byte: type
    /// lower byte: axis
    /// </summary>
    public Int16 type;
    /// <summary>
    /// bit/byte parameter
    /// </summary>
    public byte cdata;
  }; // In the case where the number of data is 1

  /// <summary>
  /// cnc_rdparam:read parameter
  /// cnc_wrparam:write parameter
  /// cnc_rdset:read setting data
  /// cnc_wrset:write setting data
  /// cnc_rdparar:read parameter(area specified)
  /// cnc_wrparas:write parameter(plural specified)
  /// cnc_rdsetr:read setting data(area specified)
  /// cnc_wrsets:write setting data(plural specified)
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct IODBPSD_CS
  {
    /// <summary>
    /// parameter number
    /// </summary>
    public Int16 datano;
    /// <summary>
    /// upper byte: type
    /// lower byte: axis
    /// </summary>
    public Int16 type;
    /// <summary>
    /// bit/byte parameter
    /// </summary>
    [MarshalAs (UnmanagedType.ByValArray, SizeConst = 32)]
    public byte[] cdatas;
  }; // In the case where the number of data is 32

  /// <summary>
  /// cnc_rdparam:read parameter
  /// cnc_wrparam:write parameter
  /// cnc_rdset:read setting data
  /// cnc_wrset:write setting data
  /// cnc_rdparar:read parameter(area specified)
  /// cnc_wrparas:write parameter(plural specified)
  /// cnc_rdsetr:read setting data(area specified)
  /// cnc_wrsets:write setting data(plural specified)
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct IODBPSD_IS
  {
    /// <summary>
    /// parameter number
    /// </summary>
    public Int16 datano;
    /// <summary>
    /// upper byte: type
    /// lower byte: axis
    /// </summary>
    public Int16 type;
    /// <summary>
    /// bit/byte parameter
    /// </summary>
    [MarshalAs (UnmanagedType.ByValArray, SizeConst = 32)]
    public Int16[] idatas;
  }; // In the case where the number of data is 32

  /// <summary>
  /// cnc_rdparam:read parameter
  /// cnc_wrparam:write parameter
  /// cnc_rdset:read setting data
  /// cnc_wrset:write setting data
  /// cnc_rdparar:read parameter(area specified)
  /// cnc_wrparas:write parameter(plural specified)
  /// cnc_rdsetr:read setting data(area specified)
  /// cnc_wrsets:write setting data(plural specified)
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct IODBPSD_LS
  {
    /// <summary>
    /// parameter number
    /// </summary>
    public Int16 datano;
    /// <summary>
    /// upper byte: type
    /// lower byte: axis
    /// </summary>
    public Int16 type;
    /// <summary>
    /// bit/byte parameter
    /// </summary>
    [MarshalAs (UnmanagedType.ByValArray, SizeConst = 32)]
    public Int32[] ldatas;
  }; // In the case where the number of data is 32

  /// <summary>
  /// 
  /// </summary>

  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct REALPRM
  {
    /// <summary>
    /// Value of variable
    /// </summary>
    public Int32 prm_val;
    /// <summary>
    /// Number of places of decimals
    /// </summary>
    public Int32 dec_val;
  }

  /// <summary>
  /// cnc_rdparam:read parameter
  /// cnc_wrparam:write parameter
  /// cnc_rdset:read setting data
  /// cnc_wrset:write setting data
  /// cnc_rdparar:read parameter(area specified)
  /// cnc_wrparas:write parameter(plural specified)
  /// cnc_rdsetr:read setting data(area specified)
  /// cnc_wrsets:write setting data(plural specified)
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct IODBPSD_RS
  {
    /// <summary>
    /// parameter number
    /// </summary>
    public Int16 datano;
    /// <summary>
    /// upper byte: type
    /// lower byte: axis
    /// </summary>
    public Int16 type;
    /// <summary>
    /// bit/byte parameter
    /// </summary>
    [MarshalAs (UnmanagedType.ByValArray, SizeConst = 32)]
    public REALPRM[] rdatas;
  }; // In the case where the number of data is 32

  /// <summary>
  /// cnc_modal:read modal data
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct MODAL_AUX_data
  {
    /// <summary>
    /// Modal data other than G code
    /// </summary>
    public int aux_data;
    /// <summary>
    /// Supplementary information
    /// </summary>
    public byte flag1;
    /// <summary>
    /// Supplementary information
    /// </summary>
    public byte flag2;
  }

  /// <summary>
  /// cnc_modal:read modal data
  /// </summary>
  [StructLayout (LayoutKind.Explicit)]
  public struct ODBMDL_1
  {
    /// <summary>
    /// Kind of modal data
    /// </summary>
    [FieldOffset (0)]
    public Int16 datano;
    /// <summary>
    /// Target block to be read
    /// </summary>
    [FieldOffset (2)]
    public Int16 type;
    /// <summary>
    /// Use for an individual reading G code (and 1 shot G code).
    /// Modal G code in the corresponding G code group
    /// </summary>
    [FieldOffset (4)]
    public byte g_data;
  }

  /// <summary>
  /// cnc_modal:read modal data
  /// </summary>
  [StructLayout (LayoutKind.Explicit)]
  public struct ODBMDL_2
  {
    /// <summary>
    /// Kind of modal data
    /// </summary>
    [FieldOffset (0)]
    public Int16 datano;
    /// <summary>
    /// Target block to be read
    /// </summary>
    [FieldOffset (2)]
    public Int16 type;
    /// <summary>
    /// Use for reading G code at a time.
    /// Modal G code in the all G code group.
    /// </summary>
    [FieldOffset (4), MarshalAs (UnmanagedType.ByValArray, SizeConst = 35)]
    public byte[] g_rdata;
    /// <summary>
    /// Use for reading 1 shot G code at a time.
    /// (In case of individual reading, use ODBMDL_1)
    /// </summary>
    [FieldOffset (4), MarshalAs (UnmanagedType.ByValArray, SizeConst = 4)]
    public byte[] g_1shot;
  }

  /// <summary>
  /// cnc_modal:read modal data
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct ODBMDL_3
  {
    /// <summary>
    /// Kind of modal data
    /// </summary>
    public Int16 datano;
    /// <summary>
    /// Target block to be read
    /// </summary>
    public Int16 type;
    /// <summary>
    /// Use for an individual reading other than G code
    /// (include axis data)
    /// </summary>
    public MODAL_AUX_data aux;
  }

  /// <summary>
  /// cnc_modal:read modal data
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct ODBMDL_4
  {
    /// <summary>
    /// Kind of modal data
    /// </summary>
    public Int16 datano;
    /// <summary>
    /// Target block to be read
    /// </summary>
    public Int16 type;
    /// <summary>
    /// Use for reading other than G code at a time
    /// </summary>
    [MarshalAs (UnmanagedType.ByValArray, SizeConst = 27)]
    public MODAL_AUX_data[] raux1;
  }

  /// <summary>
  /// cnc_modal:read modal data
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct ODBMDL_5
  {
    /// <summary>
    /// Kind of modal data
    /// </summary>
    public Int16 datano;
    /// <summary>
    /// Target block to be read
    /// </summary>
    public Int16 type;
    /// <summary>
    /// Use for reading concerning axis other than G code at a time
    /// </summary>
    [MarshalAs (UnmanagedType.ByValArray, SizeConst = 24)]
    public MODAL_AUX_data[] raux2;
  }

  /// <summary>
  /// cnc_rdcommand: read command value
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct ODBCMD_data
  {
    /// <summary>
    /// The commanded address is stored in ASCII code
    /// </summary>
    public char adrs;
    /// <summary>
    /// The following values are stored when adrs='M'
    /// <item>1: 1st M code</item>
    /// <item>2: 1st M code</item>
    /// <item>3: 1st M code</item>
    /// <item>4: 1st M code</item>
    /// <item>5: 1st M code</item>
    /// </summary>
    public byte num;
    /// <summary>
    /// The following flags are stored.
    /// <item>#3 = 1: command differ from the previous block (only Series 300i)</item>
    /// <item>#4 = 1: There is a command of a decimal point</item>
    /// <item>#5 = 1: Negative</item>
    /// <item>#6 = 1: 1 digit</item>
    /// <item>#11 = 1: There is a command after RESET</item>
    /// <item>#15 = 1: There is a command in the present block</item>
    /// </summary>
    public Int16 flag;
    /// <summary>
    /// The commanded data is stored.
    /// </summary>
    public int cmd_val;
    /// <summary>
    /// The number of places of decimals of commanded data is stored.
    /// The commanded data is calculated by the following expression.
    /// Commanded data = cmd_val * 10 ** (-dec_val)
    /// </summary>
    public int dec_val;
  }

  /// <summary>
  /// cnc_rdcommand: read command value
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct ODBCMD
  {
    [MarshalAs (UnmanagedType.ByValArray, SizeConst = 30)]
    public ODBCMD_data[] cmd;
  }

  /// <summary>
  /// cnc_rdgcode: reads the information of CNC about the commanded G code
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct ODBGCD_data
  {
    /// <summary>
    /// G code group
    /// </summary>
    public short group;
    /// <summary>
    /// Additional information
    /// </summary>
    public short flag;
    /// <summary>
    /// G Code
    /// </summary>
    [MarshalAs (UnmanagedType.ByValArray, SizeConst = 8)]
    public char[] code;
  }

  /// <summary>
  /// cnc_rdgcode: reads the information of CNC about the commanded G code
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct ODBGCD
  {
    [MarshalAs (UnmanagedType.ByValArray, SizeConst = 30)]
    public ODBGCD_data[] gcode;
  }

  /// <summary>
  /// pmc_rdpmcrng: read PMC data(area specified)
  /// pmc_wrpmcrng: write PMC data(area specified)
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct IODBPMC_CDATA
  {
    /// <summary>
    /// PMC address type
    /// </summary>
    public Int16 type_a;

    /// <summary>
    /// PMC data type: 0 is Byte, 1 is Word, 2 is Long
    /// </summary>
    public Int16 type_d;

    /// <summary>
    /// start PMC address
    /// </summary>
    public Int16 datano_s;

    /// <summary>
    /// end PMC address
    /// </summary>
    public Int16 datano_e;

    /// <summary>
    /// PMC data
    /// </summary>
    [MarshalAs (UnmanagedType.ByValArray, SizeConst = 512)]
    public byte[] cdata;
  }; /* Number of bytes up to 512 */


  // for cnc_rdalmmsg2
  [StructLayout (LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
  public struct ODBALMMSG2_data
  {
    public int alm_no;
    public Int16 type;
    public Int16 axis;
    public Int16 dummy;
    public Int16 msg_len;
    [MarshalAs (UnmanagedType.ByValTStr, SizeConst = 64)]
    public string alm_msg;
  }

  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct ODBALMMSG2
  {
    [MarshalAs (UnmanagedType.ByValArray, SizeConst = 10)]
    public ODBALMMSG2_data[] msgs;
  }

  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct IODBTLMAG_data
  {
    public Int16 magazine;     /* magazine number */
    public Int16 pot;          /* pot number */
    public Int16 tool_index;   /* tool management data number */
  }

  /// <summary>
  /// 10 IODBTLMAG_data
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct IODBTLMAG
  {
    [MarshalAs (UnmanagedType.ByValArray, SizeConst = 10)]
    public IODBTLMAG_data[] iodbtlmag;
  };

  [StructLayout (LayoutKind.Explicit, Size = 256)]
  public struct IODBTLMNG
  {
    // Common to all series
    [FieldOffset (0)] public Int32 T_code;              /* tool number (T) */
    [FieldOffset (4)] public Int32 life_count;          /* tool life counter */
    [FieldOffset (8)] public Int32 max_life;            /* maximum of tool life */
    [FieldOffset (12)] public Int32 rest_life;           /* rest of tool life */
    [FieldOffset (16)] public byte life_stat;           /* state of tool life */
    [FieldOffset (17)] public byte cust_bits;           /* customizing bit */
    [FieldOffset (18)] public UInt16 tool_info;           /* tool info. */
    [FieldOffset (20)] public Int16 H_code;              /* tool length compensation number (H) */
    [FieldOffset (22)] public Int16 D_code;              /* cutter compensation number (D) */
    [FieldOffset (24)] public Int32 spindle_speed;       /* spindle speed (S) */
    [FieldOffset (28)] public Int32 feedrate;            /* feed rate (F) */
    [FieldOffset (32)] public Int16 magazine;            /* magazine number (read only) */
    [FieldOffset (34)] public Int16 pot;                 /* pot number (read only) */
    /*      [FieldOffset( 36)] public Int16  G_code;              // tool geometric compensation number (G)
    [FieldOffset( 38)] public Int16  W_code;              // tool wear compensation number (W)
    [FieldOffset( 40)] public Int16  gno;                 // tool geometric number

    // Series 160i/180i/210i
    [FieldOffset( 42)] public Int16  A_reserve_s;
    [FieldOffset( 44)] public Int32  A_reserved_1;
    [FieldOffset( 48)] public Int32  A_reserved_2;
    [FieldOffset( 52)] public Int32  A_reserved_3;
    [FieldOffset( 56)] public Int32  A_reserved_4;

    // Series 300i
    [FieldOffset( 42)] public Int16  B_grp;               // edge group number
    [FieldOffset( 44)] public Int16  B_edge;              // edge number
    [FieldOffset( 46)] public Int16  B_reserve_s;
    [FieldOffset( 48)] public Int32  B_reserved_1;
    [FieldOffset( 52)] public Int32  B_reserved_2;
    [FieldOffset( 56)] public Int32  B_reserved_3;

    // Common to all series
    [FieldOffset( 60)] public Int32  custom1;
    [FieldOffset( 64)] public Int32  custom2;
    [FieldOffset( 68)] public Int32  custom3;
    [FieldOffset( 72)] public Int32  custom4;
    [FieldOffset( 76)] public Int32  custom5;
    [FieldOffset( 80)] public Int32  custom6;
    [FieldOffset( 84)] public Int32  custom7;
    [FieldOffset( 88)] public Int32  custom8;
    [FieldOffset( 92)] public Int32  custom9;
    [FieldOffset( 96)] public Int32  custom10;
    [FieldOffset(100)] public Int32  custom11;
    [FieldOffset(104)] public Int32  custom12;
    [FieldOffset(108)] public Int32  custom13;
    [FieldOffset(112)] public Int32  custom14;
    [FieldOffset(116)] public Int32  custom15;
    [FieldOffset(120)] public Int32  custom16;
    [FieldOffset(124)] public Int32  custom17;
    [FieldOffset(128)] public Int32  custom18;
    [FieldOffset(132)] public Int32  custom19;
    [FieldOffset(136)] public Int32  custom20; */
  };

  [StructLayout (LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
  public struct OPMSG3_data
  {
    public Int16 datano;    /* Number of operator's message */
    public Int16 type;      /* Kind of operator's message */
    public Int16 char_num;  /* Message length */

    [MarshalAs (UnmanagedType.ByValTStr, SizeConst = 256)]
    public string data;      /* Operator's message strings */
  };

  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct OPMSG3
  {
    [MarshalAs (UnmanagedType.ByValArray, SizeConst = 17)]
    public OPMSG3_data[] msgs;
  }

  /// <summary>
  /// Structure used to read 1 geometric value of a tool
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct ODBTLIFE4
  {
    public Int16 datano; // tool group number
    public Int16 type; // tool number
    public int data; // cutter radius or tool length
  };

  /// <summary>
  /// Structure used to read 2 geometric values of a tool and a status
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct IODBTD
  {
    public Int16 datano; // tool group number
    public Int16 type; // tool use-order number
    public int tool_num; // tool number
    public int h_code; // tool length compensation number
    public int d_code; // cutter radius compensation number
    public int tool_inf; // tool information (1: registered, 2: expired, 3: skipped)
  }

  /// <summary>
  /// cnc_rdprogdir2:read program directory 2
  /// </summary>
  [StructLayout (LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
  public struct PRGDIR2_data
  {
    /// <summary>
    /// Program number
    /// 
    /// Program number is returned.
    /// </summary>
#if (!ONO8D)
    public Int16 number;
#else
      public int number;
#endif
    /// <summary>
    /// Program size
    /// 
    /// Program size is returned.
    /// 
    /// Valid when 2 is specified for the arguments "type".
    /// </summary>
    public int length;
    /// <summary>
    /// CommentThe "Comment" stored next to the "Program number" in the CNC is returned.
    /// 
    /// The maximum length of the comment stored is 48 characters (50 charactersinclud- ing leading "(" and trailing ")").
    /// When the "Comment" is longer than48 characters, the part after the 48th character is ignored.
    /// 
    /// When no "Comment" is registered only parentheses ("()") are returned.
    /// 
    /// The "Comment" character string is terminated with NULL character.
    /// 
    /// Valid when 1 or 2 is specified for the argument "type". 
    /// </summary>
    [MarshalAs (UnmanagedType.ByValTStr, SizeConst = 51)]
    public string comment;
    /// <summary>
    /// 
    /// </summary>
    public byte dummy;
  }
  [StructLayout (LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
  public struct PRGDIR2
  {
    public PRGDIR2_data dir;
  } /* In case that the number of data is 1 */

  /* cnc_rdprogdir3:read program directory 3 */
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public class DIR3_MDATE
  {
    public Int16 year;
    public Int16 month;
    public Int16 day;
    public Int16 hour;
    public Int16 minute;
    public Int16 dummy;
  }
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public class DIR3_CDATE
  {
    public Int16 year;
    public Int16 month;
    public Int16 day;
    public Int16 hour;
    public Int16 minute;
    public Int16 dummy;
  }
  [StructLayout (LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
  public class PRGDIR3_data
  {
    public int number;
    public int length;
    public int page;
    [MarshalAs (UnmanagedType.ByValTStr, SizeConst = 52)]
    public string comment = new string (' ', 52);
    public DIR3_MDATE mdate = new DIR3_MDATE ();
    public DIR3_CDATE cdate = new DIR3_CDATE ();
  }
  [StructLayout (LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
  public class PRGDIR3
  {
    public PRGDIR3_data dir1 = new PRGDIR3_data ();
    public PRGDIR3_data dir2 = new PRGDIR3_data ();
    public PRGDIR3_data dir3 = new PRGDIR3_data ();
    public PRGDIR3_data dir4 = new PRGDIR3_data ();
    public PRGDIR3_data dir5 = new PRGDIR3_data ();
    public PRGDIR3_data dir6 = new PRGDIR3_data ();
    public PRGDIR3_data dir7 = new PRGDIR3_data ();
    public PRGDIR3_data dir8 = new PRGDIR3_data ();
    public PRGDIR3_data dir9 = new PRGDIR3_data ();
    public PRGDIR3_data dir10 = new PRGDIR3_data ();
  } /* In case that the number of data is 10 */


  /// <summary>
  /// cnc_rdexecpt:read execution program pointer
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct PRGPNT
  {
    /// <summary>
    /// program number
    /// </summary>
    public int prog_no;
    /// <summary>
    /// block number
    /// </summary>
    public int blk_no;
  }

  /// <summary>
  /// cnc_exeprgname:read program name under execution 
  /// </summary>
  [StructLayout (LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 4)]
  public struct ODBEXEPRG
  {
    /// <summary>
    /// running program name
    /// 
    /// the program name being executed 
    /// </summary>
    [MarshalAs (UnmanagedType.ByValTStr, SizeConst = 51)]
    public string name;
    /// <summary>
    /// running program number
    /// 
    /// the program number being executed
    /// </summary>
    public int o_num;
  }

  /// <summary>
  /// cnc_upload:upload NC program
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct ODBSEQ
  {
    /// <summary>
    /// dummy
    /// </summary>
    [MarshalAs (UnmanagedType.ByValArray, SizeConst = 2)]
    public Int16[] dummy;
    /// <summary>
    /// sequence number
    /// </summary>
    public int data;
  }


  /// <summary>
  /// cnc_rdseqnum:read sequence number under execution
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct ODBUP
  {
    /// <summary>
    /// dummy
    /// </summary>
    [MarshalAs (UnmanagedType.ByValArray, SizeConst = 2)]
    public Int16[] dummy;
    /// <summary>
    /// NC Program data
    /// </summary>
    public string data;
  }

  /// <summary>
  /// cnc_getdtailerr:get detail error
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public class ODBERR
  {
    /// <summary>
    /// err_no: Error number
    /// </summary>
    public Int16 err_no;

    /// <summary>
    /// err_dtno: Error detail number
    /// </summary>
    public Int16 err_dtno;
  }

  /// <summary>
  /// Trick for reading an array of double
  /// Warning: maximum size is 1024
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct DOUBLE_ARRAY
  {
    [MarshalAs (UnmanagedType.ByValArray, SizeConst = 1024)]
    public double[] data;
  }

  /// <summary>
  /// cnc_wrmacror2
  /// 
  /// Trick for writing an array of double
  /// Warning: maximum size is 1024
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public class DOUBLE_ARRAY_W
  {
    [MarshalAs (UnmanagedType.ByValArray, SizeConst = 1024)]
    public double[] data = new double[1024];
  }

  /// <summary>
  /// Trick for reading an array of short (int16)
  /// Warning: maximum size is 1024
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct SHORT_ARRAY
  {
    [MarshalAs (UnmanagedType.ByValArray, SizeConst = 1024)]
    public Int16[] data;
  }

  /// <summary>
  /// Tool offset information
  /// </summary>
  [StructLayout (LayoutKind.Sequential, Pack = 4)]
  public struct ODBTLINF
  {
    /// <summary>
    /// Memory type to use for reading tool offset information
    ///  0 : memory type A 
    ///  1 : memory type B 
    ///  2 : memory type C (except T series)
    /// When the tool offset for milling and turning function is valid, "10" is always read.(30i/31i/32i)
    /// </summary>
    public Int16 ofs_type;

    /// <summary>
    /// Available number of tool offset information
    /// </summary>
    public Int16 use_no;
  }

  /// <summary>
  /// cnc_ methods
  /// </summary>
  public struct FocasCnc
  {
    /// <summary>
    /// Allocate library handle 3 (for ethernet over IP)
    /// </summary>
    /// <param name="ipAddress">IP Address</param>
    /// <param name="port">Port number</param>
    /// <param name="timeOut">time out</param>
    /// <param name="handle">Handle</param>
    /// <returns></returns>
    [DllImport ("FwLib32.dll", EntryPoint = "cnc_allclibhndl3", CharSet = CharSet.Ansi)]
    public static extern Int16 allclibhndl3 (string ipAddress, UInt16 port, int timeOut, out UInt16 handle);

    /// <summary>
    /// allocate library handle 2 (for HSSB)
    /// </summary>
    /// <param name="node">HSSB node</param>
    /// <param name="handle">Handle</param>
    /// <returns></returns>
    [DllImport ("FwLib32.dll", EntryPoint = "cnc_allclibhndl2")]
    public static extern Int16 allclibhndl2 (int node, out UInt16 handle);

    [DllImport ("FwLib32.dll", EntryPoint = "cnc_allclibhndl")]
    public static extern Int16 allclibhndl (out UInt16 handle);

    /// <summary>
    /// Free library handle
    /// </summary>
    /// <param name="handle">Handle</param>
    /// <returns></returns>
    [DllImport ("FwLib32.dll", EntryPoint = "cnc_freelibhndl")]
    public static extern Int16 freelibhndl (UInt16 handle);

    /// <summary>
    /// Set path number (for 4 axes lathes, multi-path)
    /// </summary>
    /// <param name="handle">Handle</param>
    /// <param name="path">Path number</param>
    /// <returns></returns>
    [DllImport ("FwLib32.dll", EntryPoint = "cnc_setpath")]
    public static extern Int16 setpath (UInt16 handle, Int16 path);

    /// <summary>
    /// CNC information
    /// </summary>
    /// <param name="handle"></param>
    /// <param name="sysInfo"></param>
    /// <returns></returns>
    [DllImport ("FwLib32.dll", EntryPoint = "cnc_sysinfo")]
    public static extern Int16 sysinfo (UInt16 handle, out ODBSYS sysInfo);

    /// <summary>
    /// Actual feed rate
    /// </summary>
    /// <param name="handle"></param>
    /// <param name="actualfeed"></param>
    /// <returns></returns>
    [DllImport ("FwLib32.dll", EntryPoint = "cnc_actf")]
    public static extern Int16 actf (UInt16 handle, out ODBACT actualfeed);

    /// <summary>
    /// Reads program number of the program which is being currently selected in CNC.
    /// 
    /// As for Series 150i,160/180/210, 160i/180i/210i, 0i, 300i, Power Mate i, if CNC exetues the sub-program, this function can read also the main program number. In this case, that main program number is the root program number which was selected on the CNC for the execution. If the program being executed is not a sub-program, the same program number is set to both 'Running program number' and 'Main program number'.
    ///
    /// This function is used for management of NC programs in CNC by the application program, etc.
    ///
    /// The program numbers are stored in "buf.data" and 'buf.mdata" with unsigned binary format.
    /// </summary>
    /// <param name="handle"></param>
    /// <param name="prgnum"></param>
    /// <returns></returns>
    [DllImport ("FwLib32.dll", EntryPoint = "cnc_rdprgnumo8")]
    public static extern Int16 rdprgnumo8 (UInt16 handle, out ODBPROO8 prgnum);

    /// <summary>
    /// Reads the work zero offset value specified by "number", "axis".
    /// 
    /// The offset value is stored in "data[0]" of "IODBZOFS" with signed binary format.
    /// 
    /// Reads the offset value for all axes once by specifying 'ALL_AXES' in 'axis'.
    /// The offset value for each axis is stored in "data" array of "IODBZOFS".
    /// 
    /// The place of decimal point can be got by cnc_getfigure function.
    /// </summary>
    /// <param name="handle">library handle</param>
    /// <param name="number"></param>
    /// <param name="axis"></param>
    /// <param name="length"></param>
    /// <param name="zofs"></param>
    /// <returns></returns>
    [DllImport ("FwLib32.dll", EntryPoint = "cnc_rdzofs")]
    public static extern Int16 rdzofs (UInt16 handle, Int16 number, Int16 axis, Int16 length, out IODBZOFS zofs);

    /// <summary>
    /// Reads the maximum valid figures and the number of decimal places under the input/output unit,
    /// which is related to various data of CNC. 
    /// The value which is read by the window library is binary data under the unit of the CNC side.
    /// Therefore, it is nesessary to display a decimal point, etc. in consideration of the unit. 
    /// </summary>
    /// <param name="handle">library handle</param>
    /// <param name="dataType">kind of data: 0 is axis type (excluding Series 16i-W/18i-W), 1 is tool offset, 2 is custom macro, 3 is work zero offset (only for Series 16i-W/18i-W), 4 is cutting feedrate (only for Series 16i-W/18i-W)</param>
    /// <param name="validFig">maximum valid figures</param>
    /// <param name="decFigIn">array to store the number of decimal places under the input unit</param>
    /// <param name="decFigOut">array to store the number of decimal places under the output unit</param>
    /// <returns></returns>
    [DllImport ("FwLib32.dll", EntryPoint = "cnc_getfigure")]
    public static extern Int16 getfigure (UInt16 handle, Int16 dataType, ref Int16 validFig, out SHORT_ARRAY decFigIn, out SHORT_ARRAY decFigOut);

    /// <summary>
    /// Reads the CNC parameter information specified by "s_number" and "read_no".
    /// 
    /// The CNC parameter is basically non-continuous, and the attribute like the type and the size, etc. is different in each number. Use this function for such as displaying the parameter.
    /// </summary>
    /// <param name="FlibHndl">Specify the library handle.</param>
    /// <param name="s_number">Specify the start parameter number.</param>
    /// <param name="read_no">Specify the number of parameter information to be read.</param>
    /// <param name="paraif">Pointer to the ODBPARAIF structure including the parameter information.</param>
    /// <returns></returns>
    [DllImport ("FwLib32.dll", EntryPoint = "cnc_rdparainfo")]
    public static extern Int16 rdparainfo (UInt16 FlibHndl, Int16 s_number,
                                             UInt16 read_no, out ODBPARAIF paraif);

    /// <summary>
    /// Reads the parameter specified by "number", "axis" (only for the parameter
    /// with axis).  The data format depends on each parameter. The format of
    /// Byte/Word/2-Word parameter is generally signed binary format.
    /// Reads the parameter for all axes once by specifying 'ALL_AXES' (=-1) in
    /// 'axis'. The parameter for each axis is stored in each array of "IODBPSD".
    /// 
    /// The attribute of CNC parameter depends on the type and axis, and it is
    /// different for each parameter.  It is as follows, and can be got by cnc_rdparainfo function.
    /// 
    /// It is impossible to read any bit parameter bit by bit. 8 bits(i.e. 1 byte) which belong to the same parameter number are read at the same time.
    /// 
    /// See the "PARAMETER MANUAL" of CNC for details of each parameter.
    /// </summary>
    /// <param name="FlibHndl">library handle.</param>
    /// <param name="number">parameter number. See the "PARAMETER MANUAL" of CNC about available parameter number.  It can be got by cnc_rdparanum function and cnc_rdparainfo function.</param>
    /// <param name="axis">axis number. 0: assigns no axis. 1,...,m: assigns 1 axis(m=max. controlled axes). ALL_AXES: assigns all axes(ALL_AXES=-1)</param>
    /// <param name="length">data block length (size of IODBPSD structure). (4+(byte size of parameter)*(number of axis)). In case that the size of parameter is 4 byte, the IODBPSD structure is as follows.  In case that its size is 1, 2, or 8 byte, the size of data part per 1 parameter or 1 axis is 1, 2, or 8 byte. </param>
    /// <param name="param">Pointer to the IODBPSD structure including the parameter.</param>
    /// <returns></returns>
    [DllImport ("FwLib32.dll", EntryPoint = "cnc_rdparam")]
    public static extern Int16 rdparam (UInt16 FlibHndl, Int16 number,
                                          Int16 axis, Int16 length, out IODBPSD_C param);
    [DllImport ("FwLib32.dll", EntryPoint = "cnc_rdparam")]
    public static extern Int16 rdparam_byte (UInt16 FlibHndl, Int16 number,
                                          Int16 axis, Int16 length, out IODBPSD_CS param);
    [DllImport ("FwLib32.dll", EntryPoint = "cnc_rdparam")]
    public static extern Int16 rdparam_word (UInt16 FlibHndl, Int16 number,
                                          Int16 axis, Int16 length, out IODBPSD_IS param);
    [DllImport ("FwLib32.dll", EntryPoint = "cnc_rdparam")]
    public static extern Int16 rdparam_2word (UInt16 FlibHndl, Int16 number,
                                          Int16 axis, Int16 length, out IODBPSD_LS param);
    [DllImport ("FwLib32.dll", EntryPoint = "cnc_rdparam")]
    public static extern Int16 rdparam_real (UInt16 FlibHndl, Int16 number,
                                          Int16 axis, Int16 length, out IODBPSD_RS param);

    /// <summary>
    /// Axis positions
    /// </summary>
    /// <param name="handle"></param>
    /// <param name="type"></param>
    /// <param name="data_num"></param>
    /// <param name="positions"></param>
    /// <returns></returns>
    [DllImport ("FwLib32.dll", EntryPoint = "cnc_rdposition")]
    public static extern Int16 rdposition (UInt16 handle, Int16 type,
                                             ref Int16 data_num, out ODBPOS positions);
    /// <summary>
    /// read alarm status
    /// </summary>
    /// <param name="FlibHndl">Library handle</param>
    /// <param name="a">alarm status</param>
    /// <returns></returns>
    [DllImport ("FwLib32.dll", EntryPoint = "cnc_alarm2")]
    public static extern Int16 alarm2 (UInt16 FlibHndl, out int a);

    /// <summary>
    /// returns ODBALMMSG2 alarm messages structure
    /// </summary>
    /// <param name="handle">Library handle</param>
    /// <param name="alarmNumber">Number of the alarm (between 0 and 31)</param>
    /// <param name="numberOfAlarms">Number of alarm messages returned</param>
    /// <param name="alarms">Alarm messages structure returned</param>
    /// <returns></returns>
    [DllImport ("FWLIB32.dll", EntryPoint = "cnc_rdalmmsg2")]
    public static extern Int16 rdalmmsg2 (UInt16 handle,
                                         Int16 alarmNumber, ref Int16 numberOfAlarms, out ODBALMMSG2 alarms);

    /// <summary>
    /// Status info
    /// </summary>
    /// <param name="handle"></param>
    /// <param name="sysInfo"></param>
    /// <returns></returns>
    [DllImport ("FwLib32.dll", EntryPoint = "cnc_statinfo")]
    public static extern Int16 statinfo (UInt16 handle, out ODBST sysInfo);

    /// <summary>
    /// Status info for machine type 15x
    /// </summary>
    /// <param name="handle"></param>
    /// <param name="sysInfo"></param>
    /// <returns></returns>
    [DllImport ("FwLib32.dll", EntryPoint = "cnc_statinfo")]
    public static extern Int16 statinfo_150 (UInt16 handle, out ODBST_150 sysInfo);

    /// <summary>
    /// Read modal data
    /// Reads the modal information of CNC.
    /// This function cannot be used for Series 150i, so use cnc_rdgcode and cnc_rdcommand instead
    /// </summary>
    /// <param name="handle"></param>
    /// <param name="type"></param>
    /// <param name="block"></param>
    /// <param name="modal"></param>
    /// <returns></returns>
    [DllImport ("FWLIB32.dll", EntryPoint = "cnc_modal")]
    public static extern Int16 modal1 (UInt16 handle,
                                       Int16 type, Int16 block,
                                       out ODBMDL_1 modal);
    /// <summary>
    /// Read modal data
    /// Reads the modal information of CNC.
    /// This function cannot be used for Series 150i, so use cnc_rdgcode and cnc_rdcommand instead
    /// </summary>
    /// <param name="handle"></param>
    /// <param name="type"></param>
    /// <param name="block"></param>
    /// <param name="modal"></param>
    /// <returns></returns>
    [DllImport ("FWLIB32.dll", EntryPoint = "cnc_modal")]
    public static extern Int16 modal2 (UInt16 handle,
                                       Int16 type, Int16 block,
                                       out ODBMDL_2 modal);
    /// <summary>
    /// Read modal data
    /// Reads the modal information of CNC.
    /// This function cannot be used for Series 150i, so use cnc_rdgcode and cnc_rdcommand instead
    /// </summary>
    /// <param name="handle"></param>
    /// <param name="type"></param>
    /// <param name="block"></param>
    /// <param name="modal"></param>
    /// <returns></returns>
    [DllImport ("FWLIB32.dll", EntryPoint = "cnc_modal")]
    public static extern Int16 modal3 (UInt16 handle,
                                       Int16 type, Int16 block,
                                       out ODBMDL_3 modal);
    /// <summary>
    /// Read modal data
    /// Reads the modal information of CNC.
    /// This function cannot be used for Series 150i, so use cnc_rdgcode and cnc_rdcommand instead
    /// </summary>
    /// <param name="handle"></param>
    /// <param name="type"></param>
    /// <param name="block"></param>
    /// <param name="modal"></param>
    /// <returns></returns>
    [DllImport ("FWLIB32.dll", EntryPoint = "cnc_modal")]
    public static extern Int16 modal4 (UInt16 handle,
                                       Int16 type, Int16 block,
                                       out ODBMDL_4 modal);
    /// <summary>
    /// Read modal data
    /// Reads the modal information of CNC.
    /// This function cannot be used for Series 150i, so use cnc_rdgcode and cnc_rdcommand instead
    /// </summary>
    /// <param name="handle">library handle</param>
    /// <param name="type"></param>
    /// <param name="block"></param>
    /// <param name="modal"></param>
    /// <returns></returns>
    [DllImport ("FWLIB32.dll", EntryPoint = "cnc_modal")]
    public static extern Int16 modal5 (UInt16 handle,
                                       Int16 type, Int16 block,
                                       out ODBMDL_5 modal);

    /// <summary>
    /// Reads the information of CNC about the commanded G code
    /// </summary>
    /// <param name="handle">library handle</param>
    /// <param name="type">group of G code</param>
    /// <param name="block">0: previous block, 1: active block, 2: next block</param>
    /// <param name="num_gcd">number of G code to read. The actual number of data read is returned</param>
    /// <param name="g_code">array of ODBGCD structures including the G code data</param>
    /// <returns></returns>
    [DllImport ("FWLIB32.dll", EntryPoint = "cnc_rdgcode")]
    public static extern Int16 rdgcode (UInt16 handle,
                                         Int16 type, Int16 block,
                                         ref Int16 num_gcd, out ODBGCD g_code);

    /// <summary>
    /// read command value
    /// Reads the commanded data of CNC. Various information is stored in each member of ODBCMD.
    /// The readable data are the modal data except G code, and the commanded data.
    /// Only for 150i and 300i controls
    /// </summary>
    /// <param name="handle">library handle</param>
    /// <param name="type"></param>
    /// <param name="block"></param>
    /// <param name="num_cmd"></param>
    /// <param name="command"></param>
    /// <returns></returns>
    [DllImport ("FWLIB32.dll", EntryPoint = "cnc_rdcommand")]
    public static extern Int16 rdcommand (UInt16 handle,
                                           Int16 type, Int16 block,
                                           ref Int16 num_cmd,
                                           out ODBCMD command);

    /// <summary>
    /// Spindle load and spindle speed
    /// </summary>
    /// <param name="handle"></param>
    /// <param name="type"></param>
    /// <param name="data_num"></param>
    /// <param name="loadmeter"></param>
    /// <returns></returns>
    [DllImport ("FwLib32.dll", EntryPoint = "cnc_rdspmeter")]
    public static extern Int16 rdspmeter (UInt16 handle, Int16 type,
                                            ref Int16 data_num,
                                            out ODBSPLOAD loadmeter);

    /// <summary>
    /// Get custom macro type
    /// 
    /// Gets the type of custom macro variable which is used by cnc_rdmacro, cnc_wrmacro, cnc_rdmacror, cnc_wrmacror functions. 
    /// </summary>
    /// <param name="handle">Specify the library handle</param>
    /// <param name="macroType">Pointer to the custom macro variable type. 0 : decimal form floating-point type (default). none zero : binary form floating-point type</param>
    /// <returns></returns>
    [DllImport ("FWLIB32.dll", EntryPoint = "cnc_getmactype")]
    public static extern Int16 getmactype (UInt16 handle, out Int16 macroType);

    /// <summary>
    /// Read a CNC variable number
    /// </summary>
    /// <param name="handle"></param>
    /// <param name="number"></param>
    /// <param name="length"></param>
    /// <param name="macro"></param>
    /// <returns></returns>
    [DllImport ("FwLib32.dll", EntryPoint = "cnc_rdmacro")]
    public static extern Int16 rdmacro (UInt16 handle, Int16 number,
                                          Int16 length,
                                          out ODBM macro);

    /// <summary>
    /// Reads a set of custom macro variables
    /// Warning: can read 40 values, no more
    /// </summary>
    /// <param name="handle"></param>
    /// <param name="s_no">Specify the start custom macro variable number</param>
    /// <param name="e_no">Specify the end custom macro variable number</param>
    /// <param name="length">data block length, 8 + 8 * number of macro variables (max 8 + 8 * 40)</param>
    /// <param name="macror"></param>
    /// <returns></returns>
    [DllImport ("FwLib32.dll", EntryPoint = "cnc_rdmacror")]
    public static extern Int16 rdmacror (UInt16 handle,
                                          Int16 s_no,
                                          Int16 e_no,
                                          Int16 length,
                                          out IODBMR macror);

    /// <summary>
    /// Reads the custom macro variables
    /// The kinds of custom macro variable are as follows.
    /// * Local variable (#1,..,#33)
    ///   The local variables which belong to the macro program just being executed when the application program calls this function are read.
    /// * Common variable (#100,..,#999)
    ///   See the description of cnc_rdmacroinfo function about the available range of common variables.
    /// * System variable (#1000～)
    ///   In case of system variable, the variable can be read one by one at a time.
    /// * Common variable (#98000～#98499)
    ///   See the description of cnc_rdmacroinfo function about the available range of common variables.
    /// </summary>
    /// <param name="handle">library handle</param>
    /// <param name="s_no">start custom macro variable number</param>
    /// <param name="num">Number of custom macro variable. The number which was read actually is returned</param>
    /// <param name="data">data of custom macro variable</param>
    /// <returns></returns>
    [DllImport ("FwLib32.dll", EntryPoint = "cnc_rdmacror2")]
    public static extern Int16 rdmacror2 (UInt16 handle, Int32 s_no, ref Int32 num, out DOUBLE_ARRAY data);

    /// <summary>
    /// Reads the custom macro variables specified by the starting number, "s_no", and number of variables, "*num".
    /// </summary>
    /// <param name="handle">library handle</param>
    /// <param name="s_no"></param>
    /// <param name="num"></param>
    /// <param name="mcr"></param>
    /// <returns></returns>
    [DllImport ("FwLib32.dll", EntryPoint = "cnc_rdmacror3")]
    public static extern Int16 rdmacror3 (UInt16 handle,
                                            int s_no,
                                            ref int num,
                                            out IODBMRN3 mcr);

    /// <summary>
    /// Writes the custom macro variable specified by "number"
    /// 1.Common variable (#100 to #999)
    /// 2.System variable (#1000 to #9999)
    /// </summary>
    /// <param name="handle">library handle</param>
    /// <param name="number">macro variable number</param>
    /// <param name="length">Specify 10</param>
    /// <param name="mcr_val">value of variable/numerical part of variable</param>
    /// <param name="dec_val">number of places of decimals/exponent part of variable</param>
    /// <returns></returns>
    [DllImport ("FwLib32.dll", EntryPoint = "cnc_wrmacro")]
    public static extern Int16 wrmacro (UInt16 handle, Int16 number, Int16 length, Int32 mcr_val, Int16 dec_val);

    /// <summary>
    /// Writes the custom macro variables specified by the starting number
    /// Common variable (#100,..,#999)
    /// Common variable (#98000～#98499)
    /// The local variable(#1,..,#33) cannot be written.
    /// </summary>
    /// <param name="handle">library handle</param>
    /// <param name="s_no">start custom macro variable number</param>
    /// <param name="num">Number of custom macro variable. The number which was written actually is returned</param>
    /// <param name="data">data of custom macro variable</param>
    /// <returns></returns>
    [DllImport ("FwLib32.dll", EntryPoint = "cnc_wrmacror2")]
    public static extern Int16 wrmacror2 (UInt16 handle, UInt32 s_no, ref UInt32 num, DOUBLE_ARRAY_W data);

    /// <summary>
    /// Gets the type of P code macro variable which is used by cnc_rdpmacro, cnc_wrpmacro, cnc_rdpmacror, cnc_wrpmacror functions. 
    /// </summary>
    /// <param name="handle">Specify the library handle</param>
    /// <param name="pMacroType">Pointer to the macro variable type. 0 : decimal form floating-point type (default). none zero : binary form floating-point type</param>
    /// <returns></returns>
    [DllImport ("FWLIB32.dll", EntryPoint = "cnc_getpmactype")]
    public static extern Int16 getpmactype (UInt16 handle, out Int16 pMacroType);

    /// <summary>
    /// Read P code macro variables (IEEE double version)
    /// </summary>
    /// <param name="handle">Library handle</param>
    /// <param name="stnum">Starting P code macro variable number</param>
    /// <param name="num">Number of P code macro variables to be read. This function returns the total number of variables that was actually read</param>
    /// <param name="type">type of macro variables to be read: 0 - conversation, 1 - auxiliary, 2 - execution. This setting is ignored in case of P code macro variables [10000 .. 89999] and the variables for High-speed cycle cutting</param>
    /// <param name="mcval"> array for read P code macro variables. When the variable is "vacant", the 0xFFFFFFFFFFFFFFFF is set</param>
    /// <returns>EW_OK if successful. Can also be:
    /// * EW_LENGTH: data block length error. The number of P code macro variables (*num) is 0 or less
    /// * EW_NUMBER: data number error. P code macro variable number (stnum) is wrong
    /// * EW_ATTRIB: data attribute error. Type of P code macro variables (type) is wrong.
    /// * EW_NOOPT: no option. This function needs the macro-executor option
    /// </returns>
    [DllImport ("FwLib32.dll", EntryPoint = "cnc_rdpmacror2")]
    public static extern Int16 rdpmacror2 (UInt16 handle, uint stnum, ref uint num, UInt16 type, out DOUBLE_ARRAY mcval);

    /// <summary>
    /// Writes the P code macro variables(variables for the macro-executor)
    /// </summary>
    /// <param name="handle">Library handle</param>
    /// <param name="stnum">Specify the starting P code macro variable number</param>
    /// <param name="num">Specify pointer to the number of P code macro variable. The number which was written actually is returned.</param>
    /// <param name="type">Type of macro variables to be written: 0 is conversation, 1 is auxiliary, 2 is execution</param>
    /// <param name="pmacror">Array for written P code macro variables</param>
    /// <returns></returns>
    [DllImport ("FwLib32.dll", EntryPoint = "cnc_wrpmacror2")]
    public static extern Int16 wrpmacror2 (UInt16 handle, Int32 stnum, ref Int32 num, UInt16 type, DOUBLE_ARRAY pmacror);

    /// <summary>
    /// Reads the registered Tool management data number from the Magazine management table
    /// </summary>
    /// <param name="handle">library handle</param>
    /// <param name="data_num"></param>
    /// <param name="mag"></param>
    /// <returns></returns>
    [DllImport ("FwLib32.dll", EntryPoint = "cnc_rdmagazine")]
    public static extern Int16 rdmagazine (UInt16 handle,
                                            ref Int16 data_num,
                                            out IODBTLMAG mag);

    /// <summary>
    /// Reads the Tool management data which is specified by the start data number and the number of the data from the Tool management data table
    /// </summary>
    /// <param name="handle">library handle</param>
    /// <param name="startNumber">Specify the start data number for reading from the Tool management data table.</param>
    /// <param name="dataNum">Specify the pointer to the number of the reading data for reading from the Tool management data table.
    /// Set the number of the reading data(1...) to the pointed data before calling this function.
    /// This function reads the number of Tool management data specified by "*data_num", from the index specified by "s_number".
    /// After the execution of this function, *data_num holds the real read number of data. </param>
    /// <param name="tool">Specify the pointer to IODBTLMNG structure including the Tool management data to be read. As for the IODBTLMNG structure,
    /// refer to the explanation of arguments of cnc_regtool function</param>
    /// <returns></returns>
    [DllImport ("FwLib32.dll", EntryPoint = "cnc_rdtool")]
    public static extern Int16 rdtool (UInt16 handle,
                                        Int16 startNumber,
                                        ref Int16 dataNum,
                                        out IODBTLMNG tool);

    /// <summary>
    /// Reads the memory type of tool offset, and the available number of it.
    /// Those are stored in "ofs_type" and "use_no" of "ODBTLINF" with signed binary format.
    /// </summary>
    /// <param name="handle">Specify the library handle</param>
    /// <param name="tlinf">Pointer to the ODBTLINF structure for the tool offset information</param>
    /// <returns></returns>
    [DllImport ("FwLib32.dll", EntryPoint = "cnc_rdtofsinfo")]
    public static extern Int16 rdtofsinfo (UInt16 handle, out ODBTLINF tlinf);

    /// <summary>
    /// Reads the tool offset value specified by "number", "type". The offset value is stored in "data" of "ODBTOFS" with signed binary format.
    /// The unit of offset value depends on some parameters and on the machine type
    /// </summary>
    /// <param name="handle">Specify the library handle</param>
    /// <param name="number">Specify the tool offset number, the available number of tool offset being returned by cnc_rdtofsinfo</param>
    /// <param name="type">Specify the tool offset type</param>
    /// <param name="length">Specify the data block length (size of ODBTOFS structure=8). Specify 8</param>
    /// <param name="tofs">ODBTOFS structure including the tool offset value</param>
    /// <returns></returns>
    [DllImport ("FwLib32.dll", EntryPoint = "cnc_rdtofs")]
    public static extern Int16 rdtofs (UInt16 handle, Int16 number, Int16 type, Int16 length, out ODBTOFS tofs);

    /// <summary>
    /// Reads the tool offset value specified by "s_number","e_number","type".
    /// The offset values are stored in "IODBTO" with signed binary format.
    /// The unit of offset value depends on some parameters and on the machine type
    /// </summary>
    /// <param name="handle">Specify the library handle</param>
    /// <param name="s_number">Specify the start tool offset number, the available number of tool offset being returned by cnc_rdtofsinfo</param>
    /// <param name="type">Specify the tool offset type</param>
    /// <param name="e_number">Specify the end tool offset number</param>
    /// <param name="length">Specify the data block length</param>
    /// <param name="tofs">IODBTO structure including the tool offset values</param>
    /// <returns></returns>
    [DllImport ("FwLib32.dll", EntryPoint = "cnc_rdtofsr")]
    public static extern Int16 rdtofsr (UInt16 handle, Int16 s_number, Int16 type, Int16 e_number, Int16 length, out IODBTO_M_T_OFS tofs);

    /// <summary>
    /// Writes the tool offset value specified by "number", "type".
    /// The offset value must be stored in "data" with signed binary format. 
    /// </summary>
    /// <param name="handle">Specify the library handle</param>
    /// <param name="number">Specify the tool offset number, the available number of tool offset being returned by cnc_rdtofsinfo</param>
    /// <param name="type">Specify the tool offset type</param>
    /// <param name="length">Specify the data block length (size of ODBTOFS structure=8). Specify 8</param>
    /// <param name="data">Set the tool offset value</param>
    /// <returns></returns>
    [DllImport ("FwLib32.dll", EntryPoint = "cnc_wrtofs")]
    public static extern Int16 wrtofs (UInt16 handle, Int16 number, Int16 type, Int16 length, Int32 data);

    /// <summary>
    /// Writes the tool offset value specified by "datano_s","datano_e","type" (in tofsr).
    /// The offset values must be stored in "IODBTO" with signed binary format. 
    /// </summary>
    /// <param name="handle">Specify the library handle</param>
    /// <param name="length">Specify the data block length</param>
    /// <param name="tofsr">IODBTO structure including the tool offset value</param>
    /// <returns></returns>
    [DllImport ("FwLib32.dll", EntryPoint = "cnc_wrtofsr")]
    public static extern Int16 wrtofsr (UInt16 handle, Int16 length, IODBTO_M_T_OFS_W tofsr);

    /// <summary>
    /// Read op messages
    /// </summary>
    /// <param name="handle"></param>
    /// <param name="type"></param>
    /// <param name="number"></param>
    /// <param name="opmsg"></param>
    /// <returns></returns>
    [DllImport ("FwLib32.dll", EntryPoint = "cnc_rdopmsg3")]
    public static extern Int16 rdopmsg3 (UInt16 handle, Int16 type, ref Int16 number, out OPMSG3 opmsg);

    /// <summary>
    /// Reads the tool length compensation number of the specified tool group and tool number. This function is effective for only M Series. 0 is always read for T Series.
    /// This function cannot be used with Series 15i or the "Tool life management B" option of Series 16i/18i, so use cnc_rd1tlifedat2 function instead of cnc_rd1length function.
    /// And this function can be only used by the tool number of under 4 digits, so use cnc_rd1tlifedat2 function in case of setting the tool number of over 4 digits with Series 30i.
    /// </summary>
    /// <param name="handle"></param>
    /// <param name="grp_num">Specify the tool group number</param>
    /// <param name="tool_num">Specify the tool number</param>
    /// <param name="data"></param>
    /// <returns></returns>
    [DllImport ("FWLIB32.dll", EntryPoint = "cnc_rd1length")]
    public static extern Int16 rd1length (UInt16 handle,
                                           Int16 grp_num, Int16 tool_num,
                                           out ODBTLIFE4 data);

    /// <summary>
    /// Reads the cutter radius compensation number of the specified tool group and tool number
    /// This function is effective for only M Series. 0 is always read for T Series.
    /// This function cannot be used with Series 15i or the "Tool life management B" option of Series 16i/18i , so use cnc_rd1tlifedat2 function instead of cnc_rd1radius function.
    /// And this function can be only used by the tool number of under 4 digits, so use cnc_rd1tlifedat2 function in case of setting the tool number of over 4 digits with Series 30i.
    /// </summary>
    /// <param name="handle"></param>
    /// <param name="grp_num">Specify the tool group number</param>
    /// <param name="tool_num">Specify the tool number</param>
    /// <param name="data"></param>
    /// <returns></returns>
    [DllImport ("FWLIB32.dll", EntryPoint = "cnc_rd1radius")]
    public static extern Int16 rd1radius (UInt16 handle,
                                           Int16 grp_num, Int16 tool_num,
                                           out ODBTLIFE4 data);

    /// <summary>
    /// Reads the cutter radius compensation number of the specified tool group and tool number
    /// This function is effective for only M Series. 0 is always read for T Series.
    /// This function cannot be used with Series 15i or the "Tool life management B" option of Series 16i/18i , so use cnc_rd1tlifedat2 function instead of cnc_rd1radius function.
    /// And this function can be only used by the tool number of under 4 digits, so use cnc_rd1tlifedat2 function in case of setting the tool number of over 4 digits with Series 30i.
    /// </summary>
    /// <param name="handle"></param>
    /// <param name="grp_no">Specify the tool group number</param>
    /// <param name="use_no">Specify the tool number</param>
    /// <param name="data"></param>
    /// <returns></returns>
    [DllImport ("FWLIB32.dll", EntryPoint = "cnc_rd2tlifedata")]
    public static extern Int16 rd2tlifedata (UInt16 handle,
                                              Int16 grp_no, Int16 use_no,
                                              out IODBTD data);

    /// <summary>
    /// Reads the program directory of all the programs registered in the CNC.
    /// 
    /// Reads specified number of "Program Number","Comment" and "Program size (number of characters)"data
    /// of the registered programs in the CNC, starting from the program with the specified Program number.
    /// 
    /// It has the function to specify the number of programs to be read in order to get the 
    /// information corresponding to the number of programs which is set by the application. 
    /// 
    /// It is possible to use this function for the program number 8 digits, however it is necessary to 
    /// switch API to the one for the program number 8 digits.See Program number 8 digits for details.      
    /// </summary>
    /// <param name="handle">Specify the library handle.See "Library handle" for details</param>
    /// <param name="type">Specify the type of the program directory to read.  0: "Program number" only. 1: "Program number" and "Comment". 2:  "Program number", "Comment" and "Program size"</param>
    /// <param name="top_prog">Pointer to the starting program number. The program number of the first program actually read is stored after this function call. </param>
    /// <param name="num_prog">Pointer to the number of programs to be read. Actual number of programs being read is stored after this function call.</param>
    /// <param name="buf">Pointer to the PRGDIR2 structure where program directory data are returned.</param>
    /// <returns></returns>
#if (!ONO8D)
    [DllImport ("FWLIB32.dll", EntryPoint = "cnc_rdprogdir2")]
    public static extern Int16 rdprogdir2 (UInt16 handle,
        Int16 type, ref Int16 top_prog, ref Int16 num_prog, out PRGDIR2 buf);
#else
      [DllImport("FWLIB32.dll", EntryPoint="cnc_rdprogdir2o8")]
      public static extern Int16 rdprogdir2( UInt16 handle,
          Int16 type, ref Int16 top_prog, ref Int16 num_prog, [Out,MarshalAs(UnmanagedType.LPStruct)] PRGDIR2 buf);
#endif

    /// <summary>
    /// read program directory 3
    /// </summary>
    /// <param name="FlibHndl"></param>
    /// <param name="a"></param>
    /// <param name="b"></param>
    /// <param name="c"></param>
    /// <param name="buf"></param>
    /// <returns></returns>
    [DllImport ("FWLIB32.dll", EntryPoint = "cnc_rdprogdir3")]
    public static extern Int16 rdprogdir3 (UInt16 FlibHndl,
        Int16 a, ref int b, ref Int16 c, out PRGDIR3 buf);

    /// <summary>
    /// read execution program pointer 
    /// 
    /// When the CNC is MDI and MEM mode(In case of CNC is running),
    /// the program number and block number of the executed program is acquired.When the CNC is EDIT, TJOG 
    /// and THND mode(In case of CNC is editing),
    /// the program number and block number of the preread data is acquired.
    /// 
    /// The limitation of this function is as follows.
    /// 
    /// 1) CNC is in DNC/M198 operation.
    /// 
    /// 2) CNC is in RISC operation.
    /// 
    /// 3) The program number which is acquired by cnc_rdprgnum and this function is not same number.
    /// 
    /// 4) In case of FS30i-A, when STL signal is ON, the return code is EW_REJECT.
    /// 
    /// 5) In case of FS0i-D, FS30i-B and PMi-A, even if STL signal is ON, the return code is EW_OK. (when Parameter No.13104#1=1, the return code is EW_REJECT)
    /// 
    /// 6) In case of FS0i-D, FS30i-B and PMi-A, even if M198 is executed, the return code is EW_OK.
    /// 
    /// 7) In case of FS30i, FS0i-D and PMi-A, the contents of "pact" and "pnext" is same. (the preread block cannot be acquired.)
    /// 
    /// 8) The pointer information acquired with FS16i/18i/21i and FS30i/FS0i-D/PMi-A might be different depending on the running mode(or status).
    /// </summary>
    /// <param name="handle">Specify the library handle. See "Library handle" for details</param>
    /// <param name="pact">Specify the pointer to the PRGPNT structure to store the execution pointer</param>
    /// <param name="pnext">Specify the pointer to PRGPNT structure to store the preread block pointer</param>
    /// <returns></returns>
    [DllImport ("FWLIB32.dll", EntryPoint = "cnc_rdexecpt")]
    public static extern Int16 rdexecpt (UInt16 handle, out PRGPNT pact, out PRGPNT pnext);

    /// <summary>
    /// read program name under execution
    /// 
    /// Reads full path name of the program which is being currently executed in CNC.
    /// 
    /// When the CNC is stopping, the name of the executed program is acquired.
    /// 
    /// The program name is stored in "execprg.name" with maximum 32 character string format.
    /// 
    /// In case of program of O number
    /// 
    ///    exeprg.name : 'O' and the number are stored with ASCII code, for example, "O123". 
    ///    
    ///    exeprg.o_num : The O number are stored with binary format, for example, 123. 
    ///    
    /// In case of program of except O number
    /// 
    ///    exeprg.name : The program name is stored with ASCII code, for example, "ABC". 
    ///    
    ///    exeprg.o_num : 0 is stored with binary format. 
    /// </summary>
    /// <param name="handle">Specify the library handle</param>
    /// <param name="exeprg">structure including the program name being executed</param>
    /// <returns></returns>
    [DllImport ("FWLIB32.dll", EntryPoint = "cnc_exeprgname")]
    public static extern Int16 exeprgname (UInt16 handle, out ODBEXEPRG exeprg);

    /// <summary>
    /// Reads full path name of the program which is being currently executed in CNC.
    /// 
    /// When the CNC is stopping, the name of the executed program is acquired.
    /// 
    /// The program name is stored in "path_name" with maximum 256 character string format.
    /// 
    /// In case of program of O number, path_name : 'O' number is stored with ASCII code, for example, "//CNC_MEM/USER/PATH1/O123"
    /// 
    /// In case of program of except O number, path_name : The program name is stored with ASCII code, for example, "//CNC_MEM/USER/PATH1/ABC". 
    /// 
    /// When the CNC mode is MDI, "O0" is acquired.      
    /// </summary>
    /// <param name="handle"></param>
    /// <param name="path_name"></param>
    /// <returns></returns>
    [DllImport ("FWLIB32.dll", EntryPoint = "cnc_exeprgname2")]
    public static extern Int16 exeprgname2 (UInt16 handle, StringBuilder path_name);

    [DllImport ("FWLIB32.dll", EntryPoint = "cnc_pdf_rdmain")]
    public static extern Int16 pdf_rdmain (UInt16 handle, StringBuilder path_name);

    /// <summary>
    /// read block counter
    /// 
    /// Reads the value of block counter.
    /// </summary>
    /// <param name="handle"></param>
    /// <param name="prog_bc">Specify the address of the variable where the block counter is stored</param>
    /// <returns></returns>
    [DllImport ("FWLIB32.dll", EntryPoint = "cnc_rdblkcount")]
    public static extern Int16 rdblkcount (UInt16 handle, out int prog_bc);

    /// <summary>
    /// read program under execution
    /// 
    /// Reads the contents of NC program being executed on CNC.
    /// In case of 15, 30i and PMi-A, the acquired character string is a analyzed character string.
    /// If you want the acquisition of the analyzed character string on the FS0i-D, set parameter No.13104#2=1.
    /// 
    /// Note) n 16/18/21, 0i, Power Mate i, and 15, 30i, PMi-A the single block operation is different as follows.
    /// In case of 16/18/21, 0i-A/B/C, Power Mate i：- The pointer moves to the next block, and stops after the block is executed.In case of 15, 30i, 0i-D, PMi-A：- The current block is executed, and stops after the pointer moves to the next block.
    /// </summary>
    /// <param name="handle"></param>
    /// <param name="length">Specify the address of the variable which shows the number of characters to be read. Set the number of characters to be read to this variable* length(length). After reading, the number of characters actually read is set in this variable* length(length)again </param>
    /// <param name="blknum">Specify the address of the variable to store the number of blocks read in advance</param>
    /// <param name="data">Specify the top address of the string to store with the executing NC program</param>
    /// <returns></returns>
    [DllImport ("FWLIB32.dll", EntryPoint = "cnc_rdexecprog", CharSet = CharSet.Ansi)]
    public static extern Int16 rdexecprog (UInt16 handle, ref UInt16 length, out Int16 blknum, StringBuilder data);

    /// <summary>
    /// read sequence number under execution
    /// 
    /// Reads the sequence number of the NC program which is being currently executed in CNC.
    /// If the NC program has no sequence numbers in its all blocks,the sequence number of the last executed block is read.
    /// This function is used for watch the block being executed or the currentprocess by the application program, or only displaying the current sequence number.
    /// The sequence number is stored in "buf.data" with unsigned binary format. 
    /// </summary>
    /// <param name="handle"></param>
    /// <param name="seqnum">Pointer to the ODBSEQ structure including the sequence number under execution</param>
    /// <returns></returns>
    [DllImport ("FWLIB32.dll", EntryPoint = "cnc_rdseqnum")]
    public static extern Int16 rdseqnum (UInt16 handle, out ODBSEQ seqnum);

    /// <summary>
    /// Read NC program registered on the tape memory in CNC (program memory).
    /// 
    /// </summary>
    /// <param name="handle"></param>
    /// <param name="upld">Pointer to the ODBUP structure including the NC program</param>
    /// <param name="number">Specify the address of the variable which shows number of characters to be read</param>
    /// <returns></returns>
    [DllImport ("FWLIB32.dll", EntryPoint = "cnc_upload")]
    public static extern Int16 upload (UInt16 handle, out ODBUP upld, ref UInt16 number);

    /// <summary>
    /// Notifies the start of uploading NC program to the public logic of the Data window library.
    /// 
    /// This function must be executed before cnc_upload / cnc_cupload
    /// </summary>
    /// <param name="handle"></param>
    /// <param name="number">Specify the  program number to read. </param>
    /// <returns></returns>
    [DllImport ("FWLIB32.dll", EntryPoint = "cnc_upstart")]
    public static extern Int16 upstart (UInt16 handle, UInt16 number);

    /// <summary>
    /// Notifies the end of uploading NC data.
    /// 
    /// This function must be executed after cnc_upload3 function.
    /// </summary>
    /// <param name="handle"></param>
    /// <returns></returns>
    [DllImport ("FWLIB32.dll", EntryPoint = "cnc_upend")]
    public static extern Int16 upend (UInt16 handle);

    /// <summary>
    /// Read NC data registered on the memory in CNC.
    /// 
    /// This function reads the characters of NC data as long as it is specified by '*length'.
    /// However, if the number of characters to read is less than the specified number by delaying CNC data process,this function reads the characters as many as possible and then sets length' with the real number ofcharacters which are read in the buffer. 
    /// In case that this function cannot read at least one character, it returns EW_BUFFER, so again call this function with the same arguments.
    /// Because importance is attached to the speed of data transfer to the CNC, in general,return of errors(EW_DATA, etc.) may be delayed.Namely, an error status may refrect the result caused by the previously executed cnc_upload3 callings.And the error status for some cnc_upload3 callings just before the finish of uploading is returnedby cnc_upend3 function. 
    /// </summary>
    /// <param name="handle"></param>
    /// <param name="length">Specify the ponter of the variable to the character length of NC data. must be a multiple of 256 </param>
    /// <param name="data">Specify the top address of the string to store with the executing NC program</param>
    /// <returns></returns>
    [DllImport ("FWLIB32.dll", EntryPoint = "cnc_upload3")]
    public static extern Int16 upload3 (UInt16 handle, ref UInt16 length, StringBuilder data);

    /// <summary>
    /// Read NC data registered on the memory in CNC.
    /// 
    /// This function reads the characters of NC data as long as it is specified by '*length'.
    /// However, if the number of characters to read is less than the specified number by delaying CNC data process,this function reads the characters as many as possible and then sets length' with the real number ofcharacters which are read in the buffer. 
    /// In case that this function cannot read at least one character, it returns EW_BUFFER, so again call this function with the same arguments.
    /// Because importance is attached to the speed of data transfer to the CNC, in general,return of errors(EW_DATA, etc.) may be delayed.Namely, an error status may refrect the result caused by the previously executed cnc_upload3 callings.And the error status for some cnc_upload3 callings just before the finish of uploading is returnedby cnc_upend3 function. 
    /// </summary>
    /// <param name="handle"></param>
    /// <param name="length">Specify the ponter of the variable to the character length of NC data. must be a multiple of 256 </param>
    /// <param name="data">Specify the top address of the string to store with the executing NC program</param>
    /// <returns></returns>
    [DllImport ("FWLIB32.dll", EntryPoint = "cnc_upload4")]
    public static extern Int16 upload4 (UInt16 handle, ref UInt16 length, StringBuilder data);

    /// <summary>
    /// Notifies the start of uploading NC data.
    /// 
    /// This function must be executed before cnc_upload3.
    /// In case of uploading NC programs, specify the upload start program number to 's_number'and the upload end program number to 'e_number'. 
    /// In case of uploading only one program, specify its program number as s_number = e_number.
    /// </summary>
    /// <param name="handle"></param>
    /// <param name="type">Specify the kind of the data. 0 : NC program </param>
    /// <param name="s_number">Specify the start program number to read. Valid when 0 is specified for the argument "type". </param>
    /// <param name="e_number">Specify the end program number to read. Valid when 0 is specified for the argument "type". </param>
    /// <returns></returns>
    [DllImport ("FWLIB32.dll", EntryPoint = "cnc_upstart3")]
    public static extern Int16 upstart3 (UInt16 handle, UInt16 type, UInt16 s_number, UInt16 e_number);

    /// <summary>
    /// Notifies the start of uploading NC data.
    /// 
    /// This function must be executed before cnc_upload4.
    /// In case of uploading NC programs, specify the upload start program number to 's_number'and the upload end program number to 'e_number'. 
    /// In case of uploading only one program, specify its program number as s_number = e_number.
    /// </summary>
    /// <param name="handle"></param>
    /// <param name="type">Specify the kind of the data. 0 : NC program </param>
    /// <param name="file_name"></param>
    /// <returns></returns>
    [DllImport ("FWLIB32.dll", EntryPoint = "cnc_upstart4")]
    public static extern Int16 upstart4 (UInt16 handle, UInt16 type, StringBuilder file_name);

    /// <summary>
    /// Notifies the end of uploading NC data.
    /// 
    /// This function must be executed after cnc_upload3 function.
    /// </summary>
    /// <param name="handle"></param>
    /// <returns></returns>
    [DllImport ("FWLIB32.dll", EntryPoint = "cnc_upend3")]
    public static extern Int16 upend3 (UInt16 handle);


    /// <summary>
    /// Notifies the end of uploading NC data.
    /// 
    /// This function must be executed after cnc_upload4 function.
    /// </summary>
    /// <param name="handle"></param>
    /// <returns></returns>
    [DllImport ("FWLIB32.dll", EntryPoint = "cnc_upend4")]
    public static extern Int16 upend4 (UInt16 handle);

    /// <summary>
    /// Reads the NC program by line basis.
    /// 
    /// This function tries to read the amount of lines which is specified by (*line_len),
    /// but when the actual read character size reaches to the number of (*data_len) in this function, the reading process is aborted.
    /// And if the end character of the last line (EOB('\n')) is not finished to read, the last line is not counted as the read line count.
    /// </summary>
    /// <param name="handle"></param>
    /// <param name="prog_no">Specify the program number to read </param>
    /// <param name="line_no">Specify the line number to read from. When you read from the first line of a program, you have tospecify 0. </param>
    /// <param name="prog_data">Specify the address to the buffer to read the program text. </param>
    /// <param name="line_len">Specify the amount of lines to read. After calling this function, the actual read line count is set. </param>
    /// <param name="data_len">Specify the size of character to read. After calling this function, the actual read character size is set.  </param>
    /// <returns></returns>
    [DllImport ("FWLIB32.dll", EntryPoint = "cnc_rdprogline")]
    public static extern Int16 rdprogline (UInt16 handle, UInt16 prog_no, UInt16 line_no, StringBuilder prog_data, ref UInt16 line_len, ref UInt16 data_len);

    /// <summary>
    /// Reads the NC program by line basis.
    /// 
    /// This function tries to read the amount of lines which is specified by (*line_len),
    /// but when the actual read character size reaches to the number of (*data_len) in this function, the reading process is aborted.
    /// And if the end character of the last line (EOB('\n')) is not finished to read, the last line is not counted as the read line count.
    /// </summary>
    /// <param name="handle"></param>
    /// <param name="prog_no">Specify the program number to read </param>
    /// <param name="line_no">Specify the line number to read from. When you read from the first line of a program, you have tospecify 0. </param>
    /// <param name="prog_data">Specify the address to the buffer to read the program text. </param>
    /// <param name="line_len">Specify the amount of lines to read. After calling this function, the actual read line count is set. </param>
    /// <param name="data_len">Specify the size of character to read. After calling this function, the actual read character size is set.  </param>
    /// <returns></returns>
    [DllImport ("FWLIB32.dll", EntryPoint = "cnc_rdprogline2")]
    public static extern Int16 rdprogline2 (UInt16 handle, UInt16 prog_no, UInt16 line_no, StringBuilder prog_data, ref UInt16 line_len, ref UInt16 data_len);
    /// <summary>
    /// Gets the detailed error information after the function has been executed
    /// 
    /// This function must be executed after cnc_upload3 function.
    /// </summary>
    /// <param name="handle"></param>
    /// <param name="odb_error"></param>
    /// <returns></returns>
    [DllImport ("FWLIB32.dll", EntryPoint = "cnc_getdtailerr")]
    public static extern Int16 getdtailerr (UInt16 handle, out ODBERR odb_error);

    [DllImport ("FWLIB32.dll", EntryPoint = "cnc_rdpdf_subdirn")]
    public static extern Int16 rdpdf_subdirn (UInt16 handle, StringBuilder dir_name, out ODBPDFNFIL data);

  }

  /// <summary>
  /// pmc_ methods
  /// </summary>
  public struct FocasPmc
  {
    /// <summary>
    /// PMC address in pmc_rdpmcrng, pmc_wrpmcrng, pmc_rpmcinfo
    /// </summary>
    public enum ADDRESS
    {
      G = 0,
      F = 1,
      Y = 2,
      X = 3,
      A = 4,
      R = 5,
      T = 6,
      K = 7,
      C = 8,
      D = 9,
      E = 12,
      ALL = -1
    }

    /// <summary>
    /// PMC type in pmc_rdpmcrng, pmc_wrpmcrng, pmc_wrcntrldata
    /// </summary>
    public enum TYPE
    {
      BYTE = 0,
      WORD = 1,
      LONG = 2
    }

    /// <summary>
    /// Reads the PMC data of the specified PMC address/range
    /// </summary>
    /// <param name="handle">Specify the library handle</param>
    /// <param name="addressType">Specify the identification code corresponding to the kind of the PMC address</param>
    /// <param name="dataType">Specify the type of the PMC data. It must be the same one as the type of data of the PMC side. 0: Byte, 1: Word, 2: Long type</param>
    /// <param name="sNumber">Specify the start PMC address number</param>
    /// <param name="eNumber">Specify the end PMC address number</param>
    /// <param name="length">Specify the data block length. if byte: length = 8 + N, if word: length = 8 + N × 2, if long: length = 8 + N × 4</param>
    /// <param name="buffer">Pointer to the IODBPMC structure</param>
    /// <returns></returns>
    [DllImport ("FwLib32.dll", EntryPoint = "pmc_rdpmcrng")]
    public static extern Int16 rdpmcrng (UInt16 handle, Int16 addressType,
                                           Int16 dataType, UInt16 sNumber,
                                           UInt16 eNumber, UInt16 length,
                                           out IODBPMC_CDATA buffer);

    /// <summary>
    /// Writes the PMC data of the specified PMC address/range
    /// </summary>
    /// <param name="handle">Specify the library handle</param>
    /// <param name="length">Specify the data block length. if byte: length = 8 + N, if word: length = 8 + N × 2, if long: length = 8 + N × 4</param>
    /// <param name="buf">Pointer to the IODBPMC structure</param>
    /// <returns></returns>
    [DllImport ("FwLib32.dll", EntryPoint = "pmc_wrpmcrng")]
    public static extern Int16 wrpmcrng (UInt16 handle, Int16 length, IODBPMC_CDATA buf);
  }
}
